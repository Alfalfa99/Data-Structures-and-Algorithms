# 								**LeetCode刷题记录**

## 数组

### 简单

#### 1.	两数之和

```java
//通过哈希表的键值存储数组的值和键进行比对
public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i], i);
        }
        for (int i = 0; i < nums.length; i++) {
            int number = target - nums[i];
            if (map.containsKey(number) && map.get(number)!= i){
                return new int[]{i,map.get(number)};
            }
        }
        throw new IllegalArgumentException(" ");
    }
```



#### 26.	删除数组中重复数

```java
public int removeDuplicates(int[] nums) {
        if (nums.length < 2) return nums.length;
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i]!=nums[j]){	//双指针移动
                j++;
                nums[j] = nums[i];
            }
        }
        return j+1;
    }
```





#### 27.	删除数组中指定数

```java
public int removeElement(int[] nums, int val) {
        if (nums.length == 0) {
            return 0;
        }
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != val) {	//如果遇到非目标数则填充数组
                nums[j++] = nums[i];
            }
        }
        return j + 1;
    }
```



#### 35.	搜索插入位置

```java
public int searchInsert(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i]>=target){		//如果数组当前位置的元素大于或等于目标数,直接返回或插入到当前位置
                return i;
            }
        }
        return nums.length;	//通过整个比对后还没发现位置则插入到数组末尾
    }
```



#### 66.	int数组加一

```java
public static int[] plusOne(int[] digits) {
        for (int i = digits.length - 1; i >= 0; i--) {
            if (digits[i] != 9) {	//从末尾开始如果有非9的位数就+1
                digits[i]++;
                return digits;
            }
            digits[i] = 0;	//为9的位数置零
        }
        digits = new int[digits.length + 1];	//最坏情况,整个数组都是9,需要添加一位
        digits[0] = 1;	//将第一位置1,其他位默认值为0
        return digits;
    }
```



#### 88.	合并两个有序数组

```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i,j;
        for (i = m - 1, j = n - 1; i >= 0 && j >= 0; ) {  //从后向前遍历两个数组,把大的数扔到num1的尾部
            if (nums1[i] > nums2[j]) {
                nums1[i + j + 1] = nums1[i];
                i--;
            } else {
                nums1[i + j + 1] = nums2[j];
                j--;
            }
        }
        while (j >= 0){	//如果nums2没有遍历完则将nums2剩余部分替代nums1的相应部分
            nums1[j] = nums2[j];
            j--;
        }
    }
```



#### 118.	杨辉三角前n行

```java
public List<List<Integer>> generate(int numRows) {
        ArrayList<List<Integer>> arrayList = new ArrayList<>();
        if (numRows == 0){
            return arrayList;
        }
        for (int i = 0; i < numRows; i++) {
            ArrayList<Integer> list = new ArrayList<>();
            for (int j = 0; j <= i; j++) {
                if (i == 0 || j == 0 || i == j){
                    list.add(1);
                } else {
                    list.add(arrayList.get(i-1).get(j-1)+arrayList.get(i-1).get(j));
                }
            }
            arrayList.add(list);
        }
        return arrayList;
    }
```



#### 119.	杨辉三角第n行

```java
public List<Integer> getRow(int rowIndex) {
    //从0行开始数,第n行有n+1个数
    //当n >=2 的时候开始执行内层循环,将数据置于第1~n位,首位和末尾直接设置为1
        List<Integer> cur = new ArrayList<>();
        cur.add(1);	
        for (int i = 1; i <= rowIndex; i++) {
            for (int j = i - 1; j > 0; j--) {
                cur.set(j, cur.get(j - 1) + cur.get(j));
            }
            cur.add(1);	//末尾设为1
        }
        return cur;
    }
```



#### 121.	求数组中的最大差值

```java
public int maxProfit(int[] prices) {
		//前提:只能是后边的数组元素减去前边的数组元素
        int minprice = Integer.MAX_VALUE;	//设置最小值
        int maxprofit = 0;	//设置最大利润
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minprice)
                minprice = prices[i];	//如果当前值小于最小值,更新最小值
            else if (prices[i] - minprice > maxprofit)	//如果当前值减去最小值大于当前最大利润	
                maxprofit = prices[i] - minprice;	//更新最大利润
        }
        return maxprofit;
    }
```





#### 122.	求数组中的差值之和

```java
//思路:如果当前项大于上一项,则总和增加为这两项的差值
public static int maxProfit(int[] prices) {
        int maxprofit = 0;
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i-1]){
                maxprofit += prices[i] - prices[i-1];
            }
        }
        return maxprofit;
    }
```





#### 136.	只出现一次的数字

```java
public static int singleNumber(int[] nums) {
        int ans = 0;
        for (int i = 0; i < nums.length; i++) {
            ans ^= nums[i];		//数组中每两个相同的数异或之后都为0,0与只出现过一次的数异或为该数
        }
        return ans;
    }
```





#### 167.	两数之和2

```java
//和两数之和1不同,本题为递增的数组,直接从两头开始找省时省事
public static int[] twoSum(int[] numbers, int target) {
        if (numbers.length == 0){
            throw new IllegalArgumentException("");
        }
        int i = 0, j = numbers.length-1;
        while (i<j){
            if (target > numbers[i] + numbers[j]){
                i++;
            }
            if (target < numbers[i] + numbers[j]){
                j--;
            }
            if (target == numbers[i] + numbers[j]){
                return new int[]{i+1,j+1};
            }
        }
        throw new IllegalArgumentException("");
    }
```



#### 169.	寻找数组中出现次数大于一半的数

```java
//解法1:候选人算法,如果当前候选人并非上次记录的候选人,则上次记录的候选人票数减一
public static int majorityElement(int[] nums) {
        int count = 0;
        int candidate = nums[0];
        for (int num : nums) {
            if (count == 0){
                candidate = num;
            }
            count += (candidate == num)? 1:-1;
        }
        return candidate;
}
//解法2:先进行排序,出现次数大于一半的数的位置一定会出现在nums.lenth/2
public static int majorityElement(int[] nums) {
	Arrays.sort(nums);
	return nums[nums.length/2];
}
```





## 数字

### 简单

#### 7.	整数反转

```java
class Solution {
    public int reverse(int x) {
        int res = 0 ;
        while(x != 0){
            int temp = x % 10 + res * 10;
            //若发生溢出则下面该判断会为true,因为溢出后数字不确定,所以进行反操作不会获得原值
            if((temp - x % 10) / 10 != res){
                return 0 ;
            }
            res = temp ;
            x /= 10 ;
        }
        return res ;
    }
}
```



#### 9.	回文数

```java
//自己写的--思路:将整数反转后与原来的数字进行比较
class Solution {
    public boolean isPalindrome(int x) {
       int y = x;
        if (x < 0) {
            return false;
        }
        if (x == 0) {
            return true;
        }
        int res = 0;
        while (x != 0) {
            int temp = x % 10 + res * 10;
            res = temp;
            x /= 10;
        }
        if (y == res) {
            return true;
        } else {
            return false;
        }
    }
}

//参考答案--思路:只需判断前面一半的数字与后面一半的反转数字是否相同即可
class Solution {
    public boolean isPalindrome(int x) {
        if (x < 0 || (x % 10 == 0 && x != 0)) return false;	//末尾为0和小于0的数肯定为false
        int revertedNumber = 0;
        while (x > revertedNumber) {
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }
        return x == revertedNumber || x == revertedNumber / 10;	//分开讨论x为偶数和x为奇数的情况
    }
}

```

​																																		

#### 172.	阶乘后的零

```java
//纯数学题,淦!
public static int trailingZeroes(int n) {
        if (n < 5) {
            return 0;
        }
        int count = 0;
        while (n > 0) {
            n /= 5;
            count += n;
        }
        return count;
    }
```







## 字符串

### 简单

#### 13.	罗马数字转整数

```java
/*个人代码,思路:
通过HashMap存储字符与值的对,再遍历字符数组如果后一位的值大于前一位的值则说明两个字符为一个数,否则一个字符一个数*/
public int romanToInt(String s) {
        char[] chars = s.toCharArray();
        HashMap<Character, Integer> map = new HashMap<>(7);
        map.put('I', 1);
        map.put('V', 5);
        map.put('X', 10);
        map.put('L', 50);
        map.put('C', 100);
        map.put('D', 500);
        map.put('M', 1000);
        int total = 0;
        if (chars.length == 1){
            total+=map.get(chars[0]);
            return total;
        }
        for (int i = 0; i < chars.length; i++) {
            if (i+1>=chars.length) {
                total+=map.get(chars[i]);
                break;
            }
            if (map.get(chars[i]) < map.get(chars[i+1])) {
                total += map.get(chars[i + 1]) - map.get(chars[i]);
                i++;
            } else {
                total += map.get(chars[i]);
            }
        }
        if (total > 3999 && total < 1){
            throw new IllegalArgumentException();
        }
        return total;
    }
```





#### 14.	最长公共前缀

```java
public String longestCommonPrefix(String[] strs) {
        //数组长度为0直接返回
        if (strs.length == 0) {
            return "";
        }
        //初始化公共前缀
        String prefix = strs[0];
        for (int i = 1; i < strs.length; i++) {
            //如果当前串与公共前缀不相等,进入while
            while(strs[i].indexOf(prefix) != 0) {
                //将公共前缀的最后一位删除
                prefix = prefix.substring(0, prefix.length() - 1);
                //如果公共前缀删除完毕仍未找到相同部分则返回
                if (prefix.equals("")) {
                    return "";
                }
            }
        }
        return prefix;
    }
```



#### 28.	实现strStr()

```java
public int strStr(String haystack, String needle) {	//找到haystack中的needle并返回首次出现的位置
        return haystack.indexOf(needle);
    }
```



#### 38.	外观数列(说数)

```java
/**
	1.     1
	2.     11
	3.     21
	4.     1211
	5.     111221
	其实思路就在于每一步都把上一步的数说出来,n=2就说有1个1,n=3就说2个1,n=4就说1个2和1个1
**/

public static String countAndSay(int n) {
        String start = "1";
        return run(start, n - 1);
    }

    public static String run(String s, int time) {
        if (time == 0) {
            return s;
        }
        int n = s.length();
        StringBuilder sb = new StringBuilder();
        int count = 1;
        char c = s.charAt(0);
        for (int i = 1; i < n; i++) {
            if (s.charAt(i) == s.charAt(i - 1)) {
                count++;
            } else {
                sb.append(count);
                sb.append(s.charAt(i - 1));
                count = 1;
            }
        }
        sb.append(count);
        sb.append(s.charAt(n - 1));
        return run(sb.toString(), time - 1);
    }
```



#### 58.	最后一个单词的长度

```java
public static int lengthOfLastWord(String s) {
        char[] chars = s.trim().toCharArray();  //调用.trim()方法删除字符串首末的空格
        if(chars.length == 0){  //如果删除了空格之后的字符串长度为空则返回
            return 0;
        }
        for(int i = chars.length -1; i >=0; i --){  
            if(chars[i] == ' ' ){   //从尾往前,如果遇到空格则说明最后一个字符串找完了
                return chars.length-1-i;    //返回长度-空格的位置-1
            }
            if(i == 0){ //没有找到空格,说明全都是一个单词
                return chars.length;    //返回长度
            }
        }
        return 0;
    }
```



#### 67.	两个二进制数求和

```java
public static String addBinary(String a, String b) {
        int ca = 0;
        StringBuilder sb = new StringBuilder();
        for (int i = a.length() - 1, j = b.length() - 1; i >= 0 || j >= 0; i--, j--) {
            int sum = ca;
            sum += i >= 0 ? a.charAt(i) - '0' : 0;   //如果串a读完了就自动补0
            sum += j >= 0 ? b.charAt(j) - '0' : 0;   //如果串b读完了就自动补0;
            sb.append(sum % 2);                     //当前位置的数是否超过1,如果超过就取余
            ca = sum / 2;                           //把超过1的数作为余数放入下一位的运算
        }
        sb.append(ca == 1 ? ca : "");   //循环结束后还有进位数则最后填1
        return sb.reverse().toString(); //将字符串反转获得目标串,因为我们是从小位开始填充的
    }
```

​		

#### 125.	验证回文字符串

```java
public static boolean isPalindrome(String s) {
        if (s == null){
            return true;
        }
        if (s.length() == 0){
            return true;
        }
        s = s.toLowerCase();
        for (int i = 0,j = s.length()-1; i != j;) {
            if ((s.charAt(i) >= 'a' && s.charAt(i) <= 'z') || (s.charAt(i) >= '0' && s.charAt(i)<= '9')){
                if (s.charAt(j) >= 'a' && s.charAt(j) <= 'z' || s.charAt(j) >= '0' && s.charAt(j)<= '9'){
                    if (s.charAt(i) == s.charAt(j)){
                        j--;
                        i++;
                        continue;
                    }
                    return false;
                } else {
                    j--;
                }
            } else {
                i++;
            }
        }
        return true;
    }
```





#### 168.	进制问题

```java
//本题'A' = 1 ,'B' = 2,由于'Z' = 'A' + 25 , n = 26时输出'Z',所以我们要对n-1才能在取余之后获取正确的数值

public static String convertToTitle(int n) {
        StringBuilder stringBuilder = new StringBuilder();
        while (n != 0) {
            n --;//这里稍作处理，因为它是从1开始
            stringBuilder.insert(0,(char)(n % 26 + 'A'));
            n /= 26;
        }
        return stringBuilder.toString();
    }
```



#### 171.	进制问题2

```java
//从字母转回数字,26进制转10进制
public static int titleToNumber(String s) {
        if (s == null || s == ""){
            return -1;
        }
        int total = 0;
        for (int i = 0; i < s.length(); i++) {
            total = s.charAt(i) - 64 + total*26;
        }
        return total;
    }
```



## 栈

### 简单

#### 20.	括号匹配(栈)

```java
public static boolean isValid(String s) {
        if (s.length() == 0) {
            return true;
        }
        if ((s.length() & 1) == 1) {
            return false;
        }
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            switch (s.charAt(i)) {
                case '(':
                case '[':
                case '{':
                    stack.push(s.charAt(i));
                    continue;
                case ')':
                    if (stack.isEmpty() || stack.pop() != '(') {
                        return false;
                    }
                    continue;
                case ']':
                    if (stack.isEmpty() || stack.pop() != '[') {
                        return false;
                    }
                    continue;
                case '}':
                    if (stack.isEmpty() || stack.pop() != '{') {
                        return false;
                    }
                    continue;
            }
        }
        return stack.isEmpty();
    }
```



#### 155.	最小栈

```java
class MinStack {
		Stack<Integer> stack;
        int min;
        /** initialize your data structure here. */
        public MinStack() {
            stack = new Stack();
            min = Integer.MAX_VALUE;
        }

        public void push(int x) {
            if(min >= x){
                stack.push(min);
                min = x;
            }
            stack.push(x);
        }

        public void pop() {
            if(min == stack.pop()){
                min = stack.pop();
            }
        }

        public int top() {
            return stack.peek();
        }

        public int getMin() {
            return min;
        }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```





## 链表

### 简单

#### 21.	合并两个升序链表

```java
    public class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }
//通过递归写法
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {//当某一链表没有节点后直接返回另一个链表即可
            return l2;
        }
        if (l2 == null) {
            return l1;
        }
        if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);	//  l1的当前节点被使用过,将l1的下一节点继续放入递归
            return l1;	//return l1 相当于把链表中的箭头指向l1中第一个未使用的节点
        } else {
            l2.next = mergeTwoLists(l1, l2.next);	//	l2的当前节点被使用过,将l2的下一节点继续放入递归
            return l2;	//return l2 相当于把链表中的箭头指向l2中第一个未使用的节点
        }
    }

```



#### 83.	删除链表中的重复元素

```java
public ListNode deleteDuplicates(ListNode head) {
        ListNode p = head;
        while (p!= null && p.next != null){
            if (p.val == p.next.val){
                p.next = p.next.next;
            } else {
                p = p.next;
            }
        }
        return head;
    }
```





#### 141.	环形链表

```java
//思路:利用快慢指针进行判断
//如果为环形链表快指针一定会追上慢指针(套一圈)
//如果快指针到尾则说明不是环形链表;
public static boolean hasCycle(ListNode head) {
       if (head == null || head.next == null) {
            return false;
        }
        ListNode p1 = head.next;
        ListNode p2 = head;
        while (p1 != null && p1.next != null) {	//不能写反条件,否则会出错
            if (p1 == p2) {
                return true;
            }
            p1 = p1.next.next;
            p2 = p2.next;
        }
        return false;
    }
```



#### 160.	相交链表

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        ListNode p1 = headA,p2 = headB;
        while (p1 != p2) {	//让p1,p2两个指针都遍历完两根链表,如果有相交的部分,则p1一定等于p2
            p1 = p1 == null?headB:p1.next;
            p2 = p2 == null?headA:p2.next;
        }
        return p1;
    }
```





## 动态规划



### 5.	最长回文子串

```java
	/**
     * s = "abcda"
     *
     *  0 1 2 3 4 j
     * 0 T
     * 1 F T
     * 2 F F T
     * 3 F F F T
     * 4 F F F F T
     * i
     * 注意(4,0)虽然s.charAt(4) = s.charAt(0),但不能使dp[i][j] = true
     * 原因:你不能因为首末两个字母相等就说他是回文串,你要从之前的状态dp[i-1][j+1]中进行查询
     * 如果dp[i-1][j+1] == true的话及说明之前的这个子串也是回文串,直接进行子串增长操作即可
     */
    public static String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }
        Boolean[][] dp = new Boolean[len][len];
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }
        int MaxLen = 1;
        int Start = 0;

        for (int i = 1; i < len; i++) {
            for (int j = 0; j < i; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    if (i - j < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i - 1][j + 1];
                    }
                } else {
                    dp[i][j] = false;
                }
                if (dp[i][j]) {
                    int CurLen = i - j + 1;
                    if (CurLen > MaxLen) {
                        Start = j;
                        MaxLen = CurLen;
                    }
                }
            }
        }
        return s.substring(Start, Start + MaxLen);
    }
```







### 53.	最大子序和(动态规划--Kadane算法)

```java
public int maxSubArray(int[] nums) {
        int Sum = nums[0];
        for (int i = 1; i < nums.length; i++) {	//从1开始
            if (nums[i - 1] > 0) {	//如果第i-1项大于零那就加到当前项上
                nums[i] = nums[i] + nums[i - 1];	//将上一项加到这一项
            }
            Sum = Math.max(nums[i],Sum);	//判断是当前项大还是之前存储的数大
        }
        return Sum;
    }
```

​				

### 62.	不同路径

```java
public static int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                //当在数组的最上一行或最左一列时,只能由上一格向右或向下走一步而得,只有一种可能性.
                if (i == 0 || j == 0){	
                    dp[i][j] = 1;
                } else {
                    dp[i][j] = dp[i-1][j]+dp[i][j-1];
                }
            }
        }
        return dp[m-1][n-1];
    }
```



​																																			

### 70.	爬楼梯(递推型DP)

```java
public static int climbStairs(int n) {
        if (n == 1){
            return 1;
        }
        //动态规划,达到最后一层楼梯的两种可能,一种是从n-1走到n,另一种是从n-2走到n
        int[] num = new int[n+1];   //num[0]不使用
        num[1] = 1; //走到第一层只有一种走法
        num[2] = 2; //走到第二层有两种走法
        for (int i = 3; i < n + 1; i++) {
            num[i] = num[i-1]+num[i-2]; //在第n层有num[i-1]  + num[i-2]种走法
        }
        return num[n];//数组中存的每个数就代表走到该层楼的方法数量
    }
```



### 509.	第N个斐波那契数(递推型DP)

```java
public static int fib(int N) {
        int[] dp = new int[N+1];
        if (N <= 1){
            return N;
        }
        dp[0] = 0;
        dp[1] = 1;

        for (int i = 2; i <= N; i++) {
            dp[i] = dp[i-1]+dp[i-2];
        }
        return dp[N];
    }
```



### 1137.	第N个三波那契数(递推型DP)

```java
public static int tribonacci(int n) {
        int[] dp = new int[n+1];
        if (n <= 1){
            return n;
        } else if (n == 2){
            return 1;
        }
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 1;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i-3]+dp[i-2]+dp[i-1];
        }
        return dp[n];
    }
```







### 72.	编辑距离

```java
//本题可以这样看,如果增加字母则往下走,如果删除字母则往右走,如果替换则在左,左上,上三个元素中取最小+1
//若两个字母相等则不做处理
/* word1 = "cbd"
 * word2 = "cat"
 *
 *	0	1	2	3
 *	1	0	1	2
 *	2	1	1	2
 *	3	2	2	2
 */
public static int minDistance(String word1, String word2) {
        int l1 = word1.length();
        int l2 = word2.length();
        if (l1 * l2 == 0) {
            return l1+l2;
        }
        int[][] dp = new int[l1+1][l2+1];
        for (int i = 0; i < l1 + 1; i++) {
            dp[i][0] = i;
        }
        for (int i = 0; i < l2 + 1; i++) {
            dp[0][i] = i;
        }
        for (int i = 1; i <= l1; i++) {
            for (int j = 1; j <= l2; j++) {
                if (word1.charAt(i-1) == word2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1];  //左上角的坐里的步数一定是(左,左上,上)三者里最小的数(或之一)
                } else {
                    //从dp[i-1][j],dp[i-1][j-1],dp[i][j-1]里边选取最小的加1
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]),dp[i-1][j-1]) + 1;
                }
            }
        }
        return dp[l1][l2];
    }
```



### 91.	解码方法

```java
public static int numDecodings(String s) {
        int len = s.length();

        int help = 1;
        int res = 0;
        //从s的尾部开始向前遍历,如果尾部不是0则肯定有一种可能性
        if (s.charAt(len - 1) != '0') {
            res = 1;
        }
        for (int i = len - 2; i >= 0; i--) {
            if (s.charAt(i) == '0') {
                help = res;
                res = 0;
                continue;
            }
            if ((s.charAt(i) - '0') * 10 + (s.charAt(i + 1) - '0') <= 26) {
                res += help;
                //help用来存储res以前的值
                help = res-help;
            } else {
                help = res;
                //若两者都为0说明有一位为0,他的前一位大于2,既超出了26的范围,导致该0成为孤儿,所以该数肯定是错的,返回0
                if (help == 0){
                    return 0;
                }
            }

        }
        return res;
    }
```



### 95.	不同的二叉搜索树2

```java
public List<TreeNode> generateTrees(int n) {
        List<TreeNode>[] dp = new ArrayList[n+1];
        dp[0] = new ArrayList(); // 如果left或right为0，就会出现空指针异常。
        if (n == 0) return dp[0];
        dp[0].add(null);// 如果不加null，那么后面当left或right为0时，就不会执行for循环。而一旦left不执行，right也会被跳过。
        for (int i = 1; i <= n; i++) {
            dp[i] = new ArrayList();
            for (int root = 1; root <= i; root++) {
                int left = root - 1; // root为根节点，left是root左边的节点数。
                int right = i - root;// 同理，right为root右边的节点数。
                /*
                    假设n为5，root是3，那么左边有2个节点，所以去dp[2]里面找，右边也有两个节点4,5。所以还去dp[2]里面找。
                    因为只有dp[2]里面都是2个节点的数。但是dp[2]中的数只有1和2，我们要的是4,5。
                    我们不妨将1,2加上root，你会发现正好是4,5。
                    所以得到结论，左子树的值直接找前面节点数一样的dp索引，右子树的值也找前面一样的dp索引,
                    但是你需要加上root才能保证val是你需要的，所以右子树要重新创建，不然会破坏前面的树。
                */
                // 如果dp[left]里有两种可能，dp[right]里有三种可能，那么总共有6种可能。
                for (TreeNode leftTree : dp[left]) {
                    for (TreeNode rightTree : dp[right]) {
                        TreeNode newRoot = new TreeNode(root); // 这个是每一种可能的root节点。
                        newRoot.left = leftTree; // 左子树直接连接。
                        newRoot.right = clone(root, rightTree); // 右子树创建一个新的树。
                        dp[i].add(newRoot); // 将一种可能加入dp中。
                    }
                }
            }
        }
        return dp[n]; // 这个不用多说，答案在第n个数上。
    }
    
    public TreeNode clone(int val, TreeNode root) { // 重新创建一个新的子树
        if (root == null) return null; // 如果为null，返回
        TreeNode newTree = new TreeNode(val + root.val); // 创建节点时，不要忘了还要加上那个root。
        newTree.left = clone(val, root.left); // 递归左和右，和先序遍历很像。
        newTree.right = clone(val, root.right);
        return newTree; // 返回回去的这个节点正好跟在你需要的右子树上。
    }
```



### 96.	不同的二叉搜索树

```java
public static int numTrees(int n) {
        //卡特兰数 Cn = 2(2n+1)*Cn-1/(n+2)
        long C = 1;
        for (int i = 0; i < n; ++i) {
            C = C * 2 * (2 * i + 1)/(i + 2);
        }
        return (int)C;
    }
```







### 120.	三角形最小路径和

```java
public static int minimumTotal(List<List<Integer>> triangle) {
        int size = triangle.size();
        int[][] dp = new int[size][size];
        if (triangle == null || size == 0){
            return 0;
        }
        //初始化
        for (int i = 0; i < triangle.get(size-1).size(); i++) {
            dp[size-1][i] = triangle.get(size-1).get(i);
        }
        //自底向上,第i行第j个数加上第i+1行的(第j个数和第j+1个数的最小值)即为当前位置的最短路径
        for (int i = size-2; i >= 0; i--) {
            for (int j = 0; j <= i; j++) {
                dp[i][j] = triangle.get(i).get(j)+Math.min(dp[i+1][j],dp[i+1][j+1]);
            }
        }
        return dp[0][0];
    }
```





### 139.	单词拆分

```java
public static boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp = new boolean[s.length() + 1];
        //初始化,因为空串总是字典的一部分
        dp[0] = true;
        //下标i用来表示从当前字符串开始的可能的子字符串
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && wordDict.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
```



### 300.	最长上升子序列(线性DP LIS)

```java
public static int lengthOfLIS(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        // dp[]表示i个数最长子序列的长度
        int[] dp = new int[nums.length];
        //初始化整个数组都为1,因为数组中每个数都是自己的子序列,长度为1
        for (int i = 0; i < nums.length; i++) {
            dp[i] = 1;
        }
        //记录最长的子序列长度
        int max = dp[0];
        //画表格
        for (int i = 0; i < nums.length - 1; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                //从i+1开始找,如果找到一个数j,使得nums[j] > num[i],则让dp[j] = dp[i] + 1;
                //但这里有一个问题,如果当前dp[j]作为别的子序列的长度大于当前子序列长度的话,使用最长子序列的长度
                //所以状态转移方程为: dp[j] = Math.max(dp[i]+1,dp[j]);
                //如果dp[j]>max,更新max的值
                if (nums[j] > nums[i]) {
                    dp[j] = Math.max(dp[i] + 1, dp[j]);
                    if (dp[j] > max) {
                        max = dp[j];
                    }
                }
            }
        }
        return max;
    }
```



### 1143.	最长公共子序列(LCS)

```java
public static int longestCommonSubsequence(String text1, String text2) {
        char[] t1 = text1.toCharArray();
        char[] t2 = text2.toCharArray();
        int len1 = t1.length;
        int len2 = t2.length;
        int[][] dp = new int[len1+1][len2+1];
        for(int i = 1; i <= len1; i++) {
            for(int j = 1; j <= len2; j++) {
                dp[i][j] = t1[i-1] == t2[j-1] ? (dp[i-1][j-1] + 1) : Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
        return dp[len1][len2];
    }
```









### 322.	零钱兑换(完全背包)

```java
public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp,amount+1);
        dp[0] = 0;

        for (int coin : coins) {
            for (int i = coin; i <= amount ; i++) {
                dp[i] = Math.min(dp[i],dp[i-coin]+1);
            }
        }

        if (dp[amount] == amount +1){
            dp[amount] = -1;
        }
        return dp[amount];
    }
```



### 518.	零钱兑换2(完全背包)

```java
public static int change(int amount, int[] coins) {
        int[][] dp = new int[coins.length][amount+1];
        dp[0][0] = 1;
        for (int i = coins[0]; i <= amount; i++) {
            dp[0][i] = dp[0][i-coins[0]];
        }

        for (int i = 1; i < coins.length; i++) {
            for (int j = 0; j <= amount; j++) {
                dp[i][j] = dp[i-1][j];
                if (j >= coins[i]){
                    dp[i][j] = dp[i-1][j] + dp[i][j-coins[i]];
                }
            }
        }
        return dp[coins.length-1][amount];

        /**
         * 压缩后
         * int[] dp = new int[amount + 1];
         *         dp[0] = 1;
         *
         *         for (int coin : coins) {
         *             for (int x = coin; x < amount + 1; ++x) {
         *                 dp[x] += dp[x - coin];
         *             }
         *         }
         *         return dp[amount];
         */
    }
```





### 416.	分割等和子集(01背包 )

```java
public static boolean canPartition(int[] nums) {
        if(nums.length == 0){
            return false;
        }
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
        }
        if (sum % 2 != 0) {
            return false;
        }
        int target = sum / 2;
        boolean[][] dp = new boolean[nums.length][target + 1];
        //初始化
        if (nums[0] <= target) {
            dp[0][nums[0]] = true;
        }

        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j <= target; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j == nums[i]) {
                    dp[i][j] = true;
                    continue;
                }
                if (nums[i] < j) {
                    dp[i][j] = dp[i - 1][j - nums[i]] || dp[i - 1][j];
                }
            }
        }
        return dp[nums.length - 1][target];
    }
```



### 494.	目标和(01背包)

```java
public static int findTargetSumWays(int[] nums, int S) {
        int sum = 0;
        //
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
        }
        if (Math.abs(S) > sum) {
            return 0;
        }
        int border = sum * 2 + 1;
        int[][] dp = new int[nums.length][border];
        //初始化
        if (nums[0] == 0) {
            dp[0][sum] = 2;
        } else {
            dp[0][sum - nums[0]] = 1;
            dp[0][sum + nums[0]] = 1;
        }

        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < border; j++) {
                int l = j - nums[i] >= 0 ? j - nums[i] : 0;
                int r = j + nums[i] < border ? j + nums[i] : 0;
                dp[i][j] = dp[i-1][r]+dp[i-1][l];
            }
        }
        return dp[nums.length-1][S+sum];
    }
```







## 查找

### 折半查找																																						

#### 69.	x的平方根

```java
public static int mySqrt(int x) {
        if (x < 2) {
            return x;
        }
        long num;
        int pos, left = 2, right = x / 2;
        while (left <= right) {
            pos = (left + right) / 2;
            num = (long) pos * pos;
            if (num < x) {
                left = pos + 1;
            } else if (num > x) {
                right = pos - 1;
            } else {
                return pos;
            }
        }
        return right;
    }
```



### 二分查找

#### 4.	寻找两个有序数组的中位数

```java
//寻找两个数组的中位数进行比较,中位数较小的那个数组将中位数左边的数丢掉,中位数较大的那个数组将中位数右边的数丢掉,反复比对
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int m = nums2.length;
        int left = (n + m + 1) / 2;
        int right = (n + m + 2) / 2;
        //将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。
        return (getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) + getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)) * 0.5;
    }
		
    private static int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) {
        int len1 = end1 - start1 + 1;
        int len2 = end2 - start2 + 1;
        //让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1
        if (len1 > len2){
            return getKth(nums2, start2, end2, nums1, start1, end1, k);
        }
        if (len1 == 0){
            return nums2[start2 + k - 1];
        }

        if (k == 1){
            return Math.min(nums1[start1], nums2[start2]);
        }

        int i = start1 + Math.min(len1, k / 2) - 1;
        int j = start2 + Math.min(len2, k / 2) - 1;

        if (nums1[i] > nums2[j]) {
            return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));
        }
        else {
            return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));
        }
    }
```



## 树																																			

### 100.	相同的树(树)

```java
public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int x) {
            val = x;
        }
    }

    public static boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) return true;    //如果当前的节点都为null则为true,返回递归上一层
        if (p == null || q == null) return false;   //如果只有一个为null则不同
        if (p.val != q.val) return false;           //如果值不同则不同
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);//将两棵树都放入递归
    }
```



### 101.	对称的树 (树)

```java
public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int x) {
            val = x;
        }
    }

    public static boolean isSymmetric(TreeNode root) {
        if (root == null){
            return true;
        }
        return degui(root.left,root.right);
    }

    public static Boolean degui(TreeNode l, TreeNode r) {
        if (l == null && r == null) {
            return true;
        }
        if (l == null || r == null) {
            return false;
        }
        if (l.val == r.val){
            return degui(l.left,r.right) && degui(l.right,r.left);
        } else {
            return false;
        }
    }
```



### 108.	将有序数组转化为二叉搜索树

```java
int nums[];

    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums.length == 0) {
            return null;
        }
        this.nums = nums;
        return degui(0, nums.length - 1);
    }

//思路:利用分治的思想将整个数组分半,第一次找到的节点即为根节点,从左边找到的第一个节点为根节点的左孩子,右边同理
    public TreeNode degui(int left, int right) {
        if (left > right){
            return null;
        }
        int mid = (left + right) / 2;
        TreeNode treeNode = new TreeNode(this.nums[mid]);
        treeNode.left = degui(left,mid-1);	
        treeNode.right = degui(mid+1,right);
        return treeNode;
    }
```



### 108.	平衡二叉树

```java
public boolean isBalanced(TreeNode root) {
        return degui(root) != -1;
    }

    public static int degui(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = degui(root.left);	//将左子树放入递归
        if (left == -1) {	//如果某个左子树发现不平衡直接返回-1
            return -1;
        }
        int right = degui(root.right);	//将右子树放入递归
        if (right == -1) {	//如果某个右子树发现不平衡直接返回-1
            return -1;
        }
        //如果当前节点的左右子树平衡的话返回当前子树的高度并加上当前节点,否则说明不平衡返回-1
        return Math.abs(left - right) < 2 ? Math.max(left, right) + 1 : -1;	
    }
```



### 	111.	二叉树的最小深度

```java
public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = minDepth(root.left);
        int right = minDepth(root.right);
    //如果左孩子或由孩子其中一个为空则返回另一个孩子的深度并加上当前节点的深度(既+1)
    //否则返回两个非空孩子中的最小深度
        return root.left == null || root.right == null ? left + right + 1 : Math.min(left, right) + 1;    
        }
```



### 111.	二叉树寻找到叶子的路径

```java
public static boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        if (sum - root.val == 0){
            if (root.left == null && root.right == null){	//判断是否为叶子
                return true;
            }
        }
        return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);
    }
```

