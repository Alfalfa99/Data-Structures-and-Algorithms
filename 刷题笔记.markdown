# 								**LeetCode刷题记录**

## 简单

### 1.	两数之和

```java
//通过哈希表的键值存储数组的值和键进行比对
public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i], i);
        }
        for (int i = 0; i < nums.length; i++) {
            int number = target - nums[i];
            if (map.containsKey(number) && map.get(number)!= i){
                return new int[]{i,map.get(number)};
            }
        }
        throw new IllegalArgumentException(" ");
    }
```



### 7.	整数反转

```java
class Solution {
    public int reverse(int x) {
        int res = 0 ;
        while(x != 0){
            int temp = x % 10 + res * 10;
            //若发生溢出则下面该判断会为true,因为溢出后数字不确定,所以进行反操作不会获得原值
            if((temp - x % 10) / 10 != res){
                return 0 ;
            }
            res = temp ;
            x /= 10 ;
        }
        return res ;
    }
}
```



### 9.	回文数

```java
//自己写的--思路:将整数反转后与原来的数字进行比较
class Solution {
    public boolean isPalindrome(int x) {
       int y = x;
        if (x < 0) {
            return false;
        }
        if (x == 0) {
            return true;
        }
        int res = 0;
        while (x != 0) {
            int temp = x % 10 + res * 10;
            res = temp;
            x /= 10;
        }
        if (y == res) {
            return true;
        } else {
            return false;
        }
    }
}

//参考答案--思路:只需判断前面一半的数字与后面一半的反转数字是否相同即可
class Solution {
    public boolean isPalindrome(int x) {
        if (x < 0 || (x % 10 == 0 && x != 0)) return false;	//末尾为0和小于0的数肯定为false
        int revertedNumber = 0;
        while (x > revertedNumber) {
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }
        return x == revertedNumber || x == revertedNumber / 10;	//分开讨论x为偶数和x为奇数的情况
    }
}

```

​																																					--2020/3/29





### 13.	罗马数字转整数

```java
/*个人代码,思路:
通过HashMap存储字符与值的对,再遍历字符数组如果后一位的值大于前一位的值则说明两个字符为一个数,否则一个字符一个数*/
public int romanToInt(String s) {
        char[] chars = s.toCharArray();
        HashMap<Character, Integer> map = new HashMap<>(7);
        map.put('I', 1);
        map.put('V', 5);
        map.put('X', 10);
        map.put('L', 50);
        map.put('C', 100);
        map.put('D', 500);
        map.put('M', 1000);
        int total = 0;
        if (chars.length == 1){
            total+=map.get(chars[0]);
            return total;
        }
        for (int i = 0; i < chars.length; i++) {
            if (i+1>=chars.length) {
                total+=map.get(chars[i]);
                break;
            }
            if (map.get(chars[i]) < map.get(chars[i+1])) {
                total += map.get(chars[i + 1]) - map.get(chars[i]);
                i++;
            } else {
                total += map.get(chars[i]);
            }
        }
        if (total > 3999 && total < 1){
            throw new IllegalArgumentException();
        }
        return total;
    }
```





### 14.	最长公共前缀

```java
public String longestCommonPrefix(String[] strs) {
        //数组长度为0直接返回
        if (strs.length == 0) {
            return "";
        }
        //初始化公共前缀
        String prefix = strs[0];
        for (int i = 1; i < strs.length; i++) {
            //如果当前串与公共前缀不相等,进入while
            while(strs[i].indexOf(prefix) != 0) {
                //将公共前缀的最后一位删除
                prefix = prefix.substring(0, prefix.length() - 1);
                //如果公共前缀删除完毕仍未找到相同部分则返回
                if (prefix.equals("")) {
                    return "";
                }
            }
        }
        return prefix;
    }
```





### 20.	括号匹配(栈)

```java
//栈的用法
		if (s.length() == 0) {
            return true;
        }
        if ((s.length() & 1) == 1) {
            return false;
        }
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            switch (s.charAt(i)) {
                case '(':
                case '[':
                case '{':
                    stack.push(s.charAt(i));
                    continue;
                case ')':
                    if (stack.isEmpty() || stack.pop() != '(') {
                        return false;
                    }
                    continue;
                case ']':
                    if (stack.isEmpty() || stack.pop() != '[') {
                        return false;
                    }
                    continue;
                case '}':
                    if (stack.isEmpty() || stack.pop() != '{') {
                        return false;
                    }
                    continue;
            }
        }
        return stack.isEmpty();
```





### 21.	合并两个升序链表

```java
    public class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }
//通过递归写法
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {//当某一链表没有节点后直接返回另一个链表即可
            return l2;
        }
        if (l2 == null) {
            return l1;
        }
        if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);	//  l1的当前节点被使用过,将l1的下一节点继续放入递归
            return l1;	//return l1 相当于把链表中的箭头指向l1中第一个未使用的节点
        } else {
            l2.next = mergeTwoLists(l1, l2.next);	//	l2的当前节点被使用过,将l2的下一节点继续放入递归
            return l2;	//return l2 相当于把链表中的箭头指向l2中第一个未使用的节点
        }
    }

```





### 26.	删除数组中重复数

```java
public int removeDuplicates(int[] nums) {
        if (nums.length < 2) return nums.length;
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i]!=nums[j]){	//双指针移动
                j++;
                nums[j] = nums[i];
            }
        }
        return j+1;
    }
```





### 27.	删除数组中指定数

```java
public int removeElement(int[] nums, int val) {
        if (nums.length == 0) {
            return 0;
        }
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != val) {	//如果遇到非目标数则填充数组
                nums[j++] = nums[i];
            }
        }
        return j + 1;
    }
```



### 28.	实现strStr()

```java
public int strStr(String haystack, String needle) {	//找到haystack中的needle并返回首次出现的位置
        return haystack.indexOf(needle);
    }
```



### 35.	搜索插入位置

```java
public int searchInsert(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i]>=target){		//如果数组当前位置的元素大于或等于目标数,直接返回或插入到当前位置
                return i;
            }
        }
        return nums.length;	//通过整个比对后还没发现位置则插入到数组末尾
    }
```



### 38.	外观数列(说数)

```java
/**
	1.     1
	2.     11
	3.     21
	4.     1211
	5.     111221
	其实思路就在于每一步都把上一步的数说出来,n=2就说有1个1,n=3就说2个1,n=4就说1个2和1个1
**/

public static String countAndSay(int n) {
        String start = "1";
        return run(start, n - 1);
    }

    public static String run(String s, int time) {
        if (time == 0) {
            return s;
        }
        int n = s.length();
        StringBuilder sb = new StringBuilder();
        int count = 1;
        char c = s.charAt(0);
        for (int i = 1; i < n; i++) {
            if (s.charAt(i) == s.charAt(i - 1)) {
                count++;
            } else {
                sb.append(count);
                sb.append(s.charAt(i - 1));
                count = 1;
            }
        }
        sb.append(count);
        sb.append(s.charAt(n - 1));
        return run(sb.toString(), time - 1);
    }
```





### 53.	最大子序和(动态规划--Kadane算法)

```java
public int maxSubArray(int[] nums) {
        int Sum = nums[0];
        for (int i = 1; i < nums.length; i++) {	//从1开始
            if (nums[i - 1] > 0) {	//如果第i-1项大于零那就加到当前项上
                nums[i] = nums[i] + nums[i - 1];	//将上一项加到这一项
            }
            Sum = Math.max(nums[i],Sum);	//判断是当前项大还是之前存储的数大
        }
        return Sum;
    }
```

​																																							2020/4/1



### 58.	最后一个单词的长度

```java
public static int lengthOfLastWord(String s) {
        char[] chars = s.trim().toCharArray();  //调用.trim()方法删除字符串首末的空格
        if(chars.length == 0){  //如果删除了空格之后的字符串长度为空则返回
            return 0;
        }
        for(int i = chars.length -1; i >=0; i --){  
            if(chars[i] == ' ' ){   //从尾往前,如果遇到空格则说明最后一个字符串找完了
                return chars.length-1-i;    //返回长度-空格的位置-1
            }
            if(i == 0){ //没有找到空格,说明全都是一个单词
                return chars.length;    //返回长度
            }
        }
        return 0;
    }
```



​	

### 59.	int数组加一

```java
public static int[] plusOne(int[] digits) {
        for (int i = digits.length - 1; i >= 0; i--) {
            if (digits[i] != 9) {	//从末尾开始如果有非9的位数就+1
                digits[i]++;
                return digits;
            }
            digits[i] = 0;	//为9的位数置零
        }
        digits = new int[digits.length + 1];	//最坏情况,整个数组都是9,需要添加一位
        digits[0] = 1;	//将第一位置零,其他位默认值为0
        return digits;
    }
```



### 67.	两个二进制数求和

```java
public static String addBinary(String a, String b) {
        int ca = 0;
        StringBuilder sb = new StringBuilder();
        for (int i = a.length() - 1, j = b.length() - 1; i >= 0 || j >= 0; i--, j--) {
            int sum = ca;
            sum += i >= 0 ? a.charAt(i) - '0' : 0;   //如果串a读完了就自动补0
            sum += j >= 0 ? b.charAt(j) - '0' : 0;   //如果串b读完了就自动补0;
            sb.append(sum % 2);                     //当前位置的数是否超过1,如果超过就取余
            ca = sum / 2;                           //把超过1的数作为余数放入下一位的运算
        }
        sb.append(ca == 1 ? ca : "");   //循环结束后还有进位数则最后填1
        return sb.reverse().toString(); //将字符串反转获得目标串,因为我们是从小位开始填充的
    }
```

​																																								2020/4/2

### 69.	x的平方根

```java
if (x < 2) {
            return x;
        }
        long num;
        int pos, left = 2, right = x / 2;
        while (left <= right) {	//折半查找
            pos = (left + right) / 2;	//当前中值
            num = (long) pos * pos;
            if (num < x) {
                left = pos + 1;	//左标兵往右
            } else if (num > x) {
                right = pos - 1;	//右标兵往左
            } else {
                return pos;
            }
        }
        return right;
```



### 70.	爬楼梯(动态规划)

```java
public static int climbStairs(int n) {
        if (n == 1){
            return 1;
        }
        //动态规划,达到最后一层楼梯的两种可能,一种是从n-1走到n,另一种是从n-2走到n
        int[] num = new int[n+1];   //num[0]不使用
        num[1] = 1; //走到第一层只有一种走法
        num[2] = 2; //走到第二层有两种走法
        for (int i = 3; i < n + 1; i++) {
            num[i] = num[i-1]+num[i-2]; //在第n层有num[i-1]  + num[i-2]种走法
        }
        return num[n];//数组中存的每个数就代表走到该层楼的方法数量
    }
```



### 83.	删除链表中的重复元素

```java
public ListNode deleteDuplicates(ListNode head) {
        ListNode p = head;
        while (p!= null && p.next != null){
            if (p.val == p.next.val){
                p.next = p.next.next;
            } else {
                p = p.next;
            }
        }
        return head;
    }
```





​																																				2020/4/3







