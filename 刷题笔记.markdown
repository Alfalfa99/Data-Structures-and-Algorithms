# 								**LeetCode刷题记录**

## 数组

### 简单

#### 1.	两数之和

```java
//通过哈希表的键值存储数组的值和键进行比对
public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i], i);
        }
        for (int i = 0; i < nums.length; i++) {
            int number = target - nums[i];
            if (map.containsKey(number) && map.get(number)!= i){
                return new int[]{i,map.get(number)};
            }
        }
        throw new IllegalArgumentException(" ");
    }
```



#### 26.	删除数组中重复数

```java
public int removeDuplicates(int[] nums) {
        if (nums.length < 2) return nums.length;
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i]!=nums[j]){	//双指针移动
                j++;
                nums[j] = nums[i];
            }
        }
        return j+1;
    }
```





#### 27.	删除数组中指定数

```java
public int removeElement(int[] nums, int val) {
        if (nums.length == 0) {
            return 0;
        }
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != val) {	//如果遇到非目标数则填充数组
                nums[j++] = nums[i];
            }
        }
        return j + 1;
    }
```



#### 35.	搜索插入位置

```java
public int searchInsert(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i]>=target){		//如果数组当前位置的元素大于或等于目标数,直接返回或插入到当前位置
                return i;
            }
        }
        return nums.length;	//通过整个比对后还没发现位置则插入到数组末尾
    }
```



#### 66.	int数组加一

```java
public static int[] plusOne(int[] digits) {
        for (int i = digits.length - 1; i >= 0; i--) {
            if (digits[i] != 9) {	//从末尾开始如果有非9的位数就+1
                digits[i]++;
                return digits;
            }
            digits[i] = 0;	//为9的位数置零
        }
        digits = new int[digits.length + 1];	//最坏情况,整个数组都是9,需要添加一位
        digits[0] = 1;	//将第一位置1,其他位默认值为0
        return digits;
    }
```



#### 88.	合并两个有序数组

```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i,j;
        for (i = m - 1, j = n - 1; i >= 0 && j >= 0; ) {  //从后向前遍历两个数组,把大的数扔到num1的尾部
            if (nums1[i] > nums2[j]) {
                nums1[i + j + 1] = nums1[i];
                i--;
            } else {
                nums1[i + j + 1] = nums2[j];
                j--;
            }
        }
        while (j >= 0){	//如果nums2没有遍历完则将nums2剩余部分替代nums1的相应部分
            nums1[j] = nums2[j];
            j--;
        }
    }
```



#### 118.	杨辉三角前n行

```java
public List<List<Integer>> generate(int numRows) {
        ArrayList<List<Integer>> arrayList = new ArrayList<>();
        if (numRows == 0){
            return arrayList;
        }
        for (int i = 0; i < numRows; i++) {
            ArrayList<Integer> list = new ArrayList<>();
            for (int j = 0; j <= i; j++) {
                if (i == 0 || j == 0 || i == j){
                    list.add(1);
                } else {
                    list.add(arrayList.get(i-1).get(j-1)+arrayList.get(i-1).get(j));
                }
            }
            arrayList.add(list);
        }
        return arrayList;
    }
```



#### 119.	杨辉三角第n行

```java
public List<Integer> getRow(int rowIndex) {
    //从0行开始数,第n行有n+1个数
    //当n >=2 的时候开始执行内层循环,将数据置于第1~n位,首位和末尾直接设置为1
        List<Integer> cur = new ArrayList<>();
        cur.add(1);	
        for (int i = 1; i <= rowIndex; i++) {
            for (int j = i - 1; j > 0; j--) {
                cur.set(j, cur.get(j - 1) + cur.get(j));
            }
            cur.add(1);	//末尾设为1
        }
        return cur;
    }
```



#### 121.	求数组中的最大差值

```java
public int maxProfit(int[] prices) {
		//前提:只能是后边的数组元素减去前边的数组元素
        int minprice = Integer.MAX_VALUE;	//设置最小值
        int maxprofit = 0;	//设置最大利润
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minprice)
                minprice = prices[i];	//如果当前值小于最小值,更新最小值
            else if (prices[i] - minprice > maxprofit)	//如果当前值减去最小值大于当前最大利润	
                maxprofit = prices[i] - minprice;	//更新最大利润
        }
        return maxprofit;
    }
```





#### 122.	求数组中的差值之和

```java
//思路:如果当前项大于上一项,则总和增加为这两项的差值
public static int maxProfit(int[] prices) {
        int maxprofit = 0;
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i-1]){
                maxprofit += prices[i] - prices[i-1];
            }
        }
        return maxprofit;
    }
```





#### 136.	只出现一次的数字

```java
public static int singleNumber(int[] nums) {
        int ans = 0;
        for (int i = 0; i < nums.length; i++) {
            ans ^= nums[i];		//数组中每两个相同的数异或之后都为0,0与只出现过一次的数异或为该数
        }
        return ans;
    }
```





#### 167.	两数之和2

```java
//和两数之和1不同,本题为递增的数组,直接从两头开始找省时省事
public static int[] twoSum(int[] numbers, int target) {
        if (numbers.length == 0){
            throw new IllegalArgumentException("");
        }
        int i = 0, j = numbers.length-1;
        while (i<j){
            if (target > numbers[i] + numbers[j]){
                i++;
            }
            if (target < numbers[i] + numbers[j]){
                j--;
            }
            if (target == numbers[i] + numbers[j]){
                return new int[]{i+1,j+1};
            }
        }
        throw new IllegalArgumentException("");
    }
```



#### 169.	寻找数组中出现次数大于一半的数

```java
//解法1:候选人算法,如果当前候选人并非上次记录的候选人,则上次记录的候选人票数减一
public static int majorityElement(int[] nums) {
        int count = 0;
        int candidate = nums[0];
        for (int num : nums) {
            if (count == 0){
                candidate = num;
            }
            count += (candidate == num)? 1:-1;
        }
        return candidate;
}
//解法2:先进行排序,出现次数大于一半的数的位置一定会出现在nums.lenth/2
public static int majorityElement(int[] nums) {
	Arrays.sort(nums);
	return nums[nums.length/2];
}
```





## 数字

### 简单

#### 7.	整数反转

```java
class Solution {
    public int reverse(int x) {
        int res = 0 ;
        while(x != 0){
            int temp = x % 10 + res * 10;
            //若发生溢出则下面该判断会为true,因为溢出后数字不确定,所以进行反操作不会获得原值
            if((temp - x % 10) / 10 != res){
                return 0 ;
            }
            res = temp ;
            x /= 10 ;
        }
        return res ;
    }
}
```



#### 9.	回文数

```java
//自己写的--思路:将整数反转后与原来的数字进行比较
class Solution {
    public boolean isPalindrome(int x) {
       int y = x;
        if (x < 0) {
            return false;
        }
        if (x == 0) {
            return true;
        }
        int res = 0;
        while (x != 0) {
            int temp = x % 10 + res * 10;
            res = temp;
            x /= 10;
        }
        if (y == res) {
            return true;
        } else {
            return false;
        }
    }
}

//参考答案--思路:只需判断前面一半的数字与后面一半的反转数字是否相同即可
class Solution {
    public boolean isPalindrome(int x) {
        if (x < 0 || (x % 10 == 0 && x != 0)) return false;	//末尾为0和小于0的数肯定为false
        int revertedNumber = 0;
        while (x > revertedNumber) {
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }
        return x == revertedNumber || x == revertedNumber / 10;	//分开讨论x为偶数和x为奇数的情况
    }
}

```

​																																		

#### 172.	阶乘后的零

```java
//纯数学题,淦!
public static int trailingZeroes(int n) {
        if (n < 5) {
            return 0;
        }
        int count = 0;
        while (n > 0) {
            n /= 5;
            count += n;
        }
        return count;
    }
```







## 字符串

### 简单

#### 13.	罗马数字转整数

```java
/*个人代码,思路:
通过HashMap存储字符与值的对,再遍历字符数组如果后一位的值大于前一位的值则说明两个字符为一个数,否则一个字符一个数*/
public int romanToInt(String s) {
        char[] chars = s.toCharArray();
        HashMap<Character, Integer> map = new HashMap<>(7);
        map.put('I', 1);
        map.put('V', 5);
        map.put('X', 10);
        map.put('L', 50);
        map.put('C', 100);
        map.put('D', 500);
        map.put('M', 1000);
        int total = 0;
        if (chars.length == 1){
            total+=map.get(chars[0]);
            return total;
        }
        for (int i = 0; i < chars.length; i++) {
            if (i+1>=chars.length) {
                total+=map.get(chars[i]);
                break;
            }
            if (map.get(chars[i]) < map.get(chars[i+1])) {
                total += map.get(chars[i + 1]) - map.get(chars[i]);
                i++;
            } else {
                total += map.get(chars[i]);
            }
        }
        if (total > 3999 && total < 1){
            throw new IllegalArgumentException();
        }
        return total;
    }
```





#### 14.	最长公共前缀

```java
public String longestCommonPrefix(String[] strs) {
        //数组长度为0直接返回
        if (strs.length == 0) {
            return "";
        }
        //初始化公共前缀
        String prefix = strs[0];
        for (int i = 1; i < strs.length; i++) {
            //如果当前串与公共前缀不相等,进入while
            while(strs[i].indexOf(prefix) != 0) {
                //将公共前缀的最后一位删除
                prefix = prefix.substring(0, prefix.length() - 1);
                //如果公共前缀删除完毕仍未找到相同部分则返回
                if (prefix.equals("")) {
                    return "";
                }
            }
        }
        return prefix;
    }
```



#### 28.	实现strStr()

```java
public int strStr(String haystack, String needle) {	//找到haystack中的needle并返回首次出现的位置
        return haystack.indexOf(needle);
    }
```



#### 38.	外观数列(说数)

```java
/**
	1.     1
	2.     11
	3.     21
	4.     1211
	5.     111221
	其实思路就在于每一步都把上一步的数说出来,n=2就说有1个1,n=3就说2个1,n=4就说1个2和1个1
**/

public static String countAndSay(int n) {
        String start = "1";
        return run(start, n - 1);
    }

    public static String run(String s, int time) {
        if (time == 0) {
            return s;
        }
        int n = s.length();
        StringBuilder sb = new StringBuilder();
        int count = 1;
        char c = s.charAt(0);
        for (int i = 1; i < n; i++) {
            if (s.charAt(i) == s.charAt(i - 1)) {
                count++;
            } else {
                sb.append(count);
                sb.append(s.charAt(i - 1));
                count = 1;
            }
        }
        sb.append(count);
        sb.append(s.charAt(n - 1));
        return run(sb.toString(), time - 1);
    }
```



#### 58.	最后一个单词的长度

```java
public static int lengthOfLastWord(String s) {
        char[] chars = s.trim().toCharArray();  //调用.trim()方法删除字符串首末的空格
        if(chars.length == 0){  //如果删除了空格之后的字符串长度为空则返回
            return 0;
        }
        for(int i = chars.length -1; i >=0; i --){  
            if(chars[i] == ' ' ){   //从尾往前,如果遇到空格则说明最后一个字符串找完了
                return chars.length-1-i;    //返回长度-空格的位置-1
            }
            if(i == 0){ //没有找到空格,说明全都是一个单词
                return chars.length;    //返回长度
            }
        }
        return 0;
    }
```



#### 67.	两个二进制数求和

```java
public static String addBinary(String a, String b) {
        int ca = 0;
        StringBuilder sb = new StringBuilder();
        for (int i = a.length() - 1, j = b.length() - 1; i >= 0 || j >= 0; i--, j--) {
            int sum = ca;
            sum += i >= 0 ? a.charAt(i) - '0' : 0;   //如果串a读完了就自动补0
            sum += j >= 0 ? b.charAt(j) - '0' : 0;   //如果串b读完了就自动补0;
            sb.append(sum % 2);                     //当前位置的数是否超过1,如果超过就取余
            ca = sum / 2;                           //把超过1的数作为余数放入下一位的运算
        }
        sb.append(ca == 1 ? ca : "");   //循环结束后还有进位数则最后填1
        return sb.reverse().toString(); //将字符串反转获得目标串,因为我们是从小位开始填充的
    }
```

​		

#### 125.	验证回文字符串

```java
public static boolean isPalindrome(String s) {
        if (s == null){
            return true;
        }
        if (s.length() == 0){
            return true;
        }
        s = s.toLowerCase();
        for (int i = 0,j = s.length()-1; i != j;) {
            if ((s.charAt(i) >= 'a' && s.charAt(i) <= 'z') || (s.charAt(i) >= '0' && s.charAt(i)<= '9')){
                if (s.charAt(j) >= 'a' && s.charAt(j) <= 'z' || s.charAt(j) >= '0' && s.charAt(j)<= '9'){
                    if (s.charAt(i) == s.charAt(j)){
                        j--;
                        i++;
                        continue;
                    }
                    return false;
                } else {
                    j--;
                }
            } else {
                i++;
            }
        }
        return true;
    }
```





#### 168.	进制问题

```java
//本题'A' = 1 ,'B' = 2,由于'Z' = 'A' + 25 , n = 26时输出'Z',所以我们要对n-1才能在取余之后获取正确的数值

public static String convertToTitle(int n) {
        StringBuilder stringBuilder = new StringBuilder();
        while (n != 0) {
            n --;//这里稍作处理，因为它是从1开始
            stringBuilder.insert(0,(char)(n % 26 + 'A'));
            n /= 26;
        }
        return stringBuilder.toString();
    }
```



#### 171.	进制问题2

```java
//从字母转回数字,26进制转10进制
public static int titleToNumber(String s) {
        if (s == null || s == ""){
            return -1;
        }
        int total = 0;
        for (int i = 0; i < s.length(); i++) {
            total = s.charAt(i) - 64 + total*26;
        }
        return total;
    }
```



## 栈

### 简单

#### 20.	括号匹配(栈)

```java
public static boolean isValid(String s) {
        if (s.length() == 0) {
            return true;
        }
        if ((s.length() & 1) == 1) {
            return false;
        }
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            switch (s.charAt(i)) {
                case '(':
                case '[':
                case '{':
                    stack.push(s.charAt(i));
                    continue;
                case ')':
                    if (stack.isEmpty() || stack.pop() != '(') {
                        return false;
                    }
                    continue;
                case ']':
                    if (stack.isEmpty() || stack.pop() != '[') {
                        return false;
                    }
                    continue;
                case '}':
                    if (stack.isEmpty() || stack.pop() != '{') {
                        return false;
                    }
                    continue;
            }
        }
        return stack.isEmpty();
    }
```



#### 155.	最小栈

```java
class MinStack {
		Stack<Integer> stack;
        int min;
        /** initialize your data structure here. */
        public MinStack() {
            stack = new Stack();
            min = Integer.MAX_VALUE;
        }

        public void push(int x) {
            if(min >= x){
                stack.push(min);
                min = x;
            }
            stack.push(x);
        }

        public void pop() {
            if(min == stack.pop()){
                min = stack.pop();
            }
        }

        public int top() {
            return stack.peek();
        }

        public int getMin() {
            return min;
        }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```





## 链表

### 简单

#### 21.	合并两个升序链表

```java
    public class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }
//通过递归写法
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {//当某一链表没有节点后直接返回另一个链表即可
            return l2;
        }
        if (l2 == null) {
            return l1;
        }
        if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);	//  l1的当前节点被使用过,将l1的下一节点继续放入递归
            return l1;	//return l1 相当于把链表中的箭头指向l1中第一个未使用的节点
        } else {
            l2.next = mergeTwoLists(l1, l2.next);	//	l2的当前节点被使用过,将l2的下一节点继续放入递归
            return l2;	//return l2 相当于把链表中的箭头指向l2中第一个未使用的节点
        }
    }

```



#### 83.	删除链表中的重复元素

```java
public ListNode deleteDuplicates(ListNode head) {
        ListNode p = head;
        while (p!= null && p.next != null){
            if (p.val == p.next.val){
                p.next = p.next.next;
            } else {
                p = p.next;
            }
        }
        return head;
    }
```





#### 141.	环形链表

```java
//思路:利用快慢指针进行判断
//如果为环形链表快指针一定会追上慢指针(套一圈)
//如果快指针到尾则说明不是环形链表;
public static boolean hasCycle(ListNode head) {
       if (head == null || head.next == null) {
            return false;
        }
        ListNode p1 = head.next;
        ListNode p2 = head;
        while (p1 != null && p1.next != null) {	//不能写反条件,否则会出错
            if (p1 == p2) {
                return true;
            }
            p1 = p1.next.next;
            p2 = p2.next;
        }
        return false;
    }
```



#### 160.	相交链表

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        ListNode p1 = headA,p2 = headB;
        while (p1 != p2) {	//让p1,p2两个指针都遍历完两根链表,如果有相交的部分,则p1一定等于p2
            p1 = p1 == null?headB:p1.next;
            p2 = p2 == null?headA:p2.next;
        }
        return p1;
    }
```





## 动态规划

### 简单

#### 53.	最大子序和(动态规划--Kadane算法)

```java
public int maxSubArray(int[] nums) {
        int Sum = nums[0];
        for (int i = 1; i < nums.length; i++) {	//从1开始
            if (nums[i - 1] > 0) {	//如果第i-1项大于零那就加到当前项上
                nums[i] = nums[i] + nums[i - 1];	//将上一项加到这一项
            }
            Sum = Math.max(nums[i],Sum);	//判断是当前项大还是之前存储的数大
        }
        return Sum;
    }
```

​				

#### 62.	不同路径

```java
public static int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                //当在数组的最上一行或最左一列时,只能由上一格向右或向下走一步而得,只有一种可能性.
                if (i == 0 || j == 0){	
                    dp[i][j] = 1;
                } else {
                    dp[i][j] = dp[i-1][j]+dp[i][j-1];
                }
            }
        }
        return dp[m-1][n-1];
    }
```



​																																			

#### 70.	爬楼梯(动态规划)

```java
public static int climbStairs(int n) {
        if (n == 1){
            return 1;
        }
        //动态规划,达到最后一层楼梯的两种可能,一种是从n-1走到n,另一种是从n-2走到n
        int[] num = new int[n+1];   //num[0]不使用
        num[1] = 1; //走到第一层只有一种走法
        num[2] = 2; //走到第二层有两种走法
        for (int i = 3; i < n + 1; i++) {
            num[i] = num[i-1]+num[i-2]; //在第n层有num[i-1]  + num[i-2]种走法
        }
        return num[n];//数组中存的每个数就代表走到该层楼的方法数量
    }
```





#### 72.	编辑距离

```java
//本题可以这样看,如果增加字母则往下走,如果删除字母则往右走,如果替换则在左,左上,上三个元素中取最小+1
//若两个字母相等则不做处理
/* word1 = "cbd"
 * word2 = "cat"
 *
 *	0	1	2	3
 *	1	0	1	2
 *	2	1	1	2
 *	3	2	2	2
 */
public static int minDistance(String word1, String word2) {
        int l1 = word1.length();
        int l2 = word2.length();
        if (l1 * l2 == 0) {
            return l1+l2;
        }
        int[][] dp = new int[l1+1][l2+1];
        for (int i = 0; i < l1 + 1; i++) {
            dp[i][0] = i;
        }
        for (int i = 0; i < l2 + 1; i++) {
            dp[0][i] = i;
        }
        for (int i = 1; i <= l1; i++) {
            for (int j = 1; j <= l2; j++) {
                if (word1.charAt(i-1) == word2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1];  //左上角的坐里的步数一定是(左,左上,上)三者里最小的数(或之一)
                } else {
                    //从dp[i-1][j],dp[i-1][j-1],dp[i][j-1]里边选取最小的加1
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]),dp[i-1][j-1]) + 1;
                }
            }
        }
        return dp[l1][l2];
    }
```







## 查找

### 折半查找																																						

#### 69.	x的平方根

```java
public static int mySqrt(int x) {
        if (x < 2) {
            return x;
        }
        long num;
        int pos, left = 2, right = x / 2;
        while (left <= right) {
            pos = (left + right) / 2;
            num = (long) pos * pos;
            if (num < x) {
                left = pos + 1;
            } else if (num > x) {
                right = pos - 1;
            } else {
                return pos;
            }
        }
        return right;
    }
```



### 二分查找

#### 4.	寻找两个有序数组的中位数

```java
//寻找两个数组的中位数进行比较,中位数较小的那个数组将中位数左边的数丢掉,中位数较大的那个数组将中位数右边的数丢掉,反复比对
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int m = nums2.length;
        int left = (n + m + 1) / 2;
        int right = (n + m + 2) / 2;
        //将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。
        return (getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) + getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)) * 0.5;
    }
		
    private static int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) {
        int len1 = end1 - start1 + 1;
        int len2 = end2 - start2 + 1;
        //让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1
        if (len1 > len2){
            return getKth(nums2, start2, end2, nums1, start1, end1, k);
        }
        if (len1 == 0){
            return nums2[start2 + k - 1];
        }

        if (k == 1){
            return Math.min(nums1[start1], nums2[start2]);
        }

        int i = start1 + Math.min(len1, k / 2) - 1;
        int j = start2 + Math.min(len2, k / 2) - 1;

        if (nums1[i] > nums2[j]) {
            return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));
        }
        else {
            return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));
        }
    }
```



## 树																																			

### 100.	相同的树(树)

```java
public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int x) {
            val = x;
        }
    }

    public static boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) return true;    //如果当前的节点都为null则为true,返回递归上一层
        if (p == null || q == null) return false;   //如果只有一个为null则不同
        if (p.val != q.val) return false;           //如果值不同则不同
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);//将两棵树都放入递归
    }
```



### 101.	对称的树 (树)

```java
public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int x) {
            val = x;
        }
    }

    public static boolean isSymmetric(TreeNode root) {
        if (root == null){
            return true;
        }
        return degui(root.left,root.right);
    }

    public static Boolean degui(TreeNode l, TreeNode r) {
        if (l == null && r == null) {
            return true;
        }
        if (l == null || r == null) {
            return false;
        }
        if (l.val == r.val){
            return degui(l.left,r.right) && degui(l.right,r.left);
        } else {
            return false;
        }
    }
```



### 108.	将有序数组转化为二叉搜索树

```java
int nums[];

    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums.length == 0) {
            return null;
        }
        this.nums = nums;
        return degui(0, nums.length - 1);
    }

//思路:利用分治的思想将整个数组分半,第一次找到的节点即为根节点,从左边找到的第一个节点为根节点的左孩子,右边同理
    public TreeNode degui(int left, int right) {
        if (left > right){
            return null;
        }
        int mid = (left + right) / 2;
        TreeNode treeNode = new TreeNode(this.nums[mid]);
        treeNode.left = degui(left,mid-1);	
        treeNode.right = degui(mid+1,right);
        return treeNode;
    }
```



### 108.	平衡二叉树

```java
public boolean isBalanced(TreeNode root) {
        return degui(root) != -1;
    }

    public static int degui(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = degui(root.left);	//将左子树放入递归
        if (left == -1) {	//如果某个左子树发现不平衡直接返回-1
            return -1;
        }
        int right = degui(root.right);	//将右子树放入递归
        if (right == -1) {	//如果某个右子树发现不平衡直接返回-1
            return -1;
        }
        //如果当前节点的左右子树平衡的话返回当前子树的高度并加上当前节点,否则说明不平衡返回-1
        return Math.abs(left - right) < 2 ? Math.max(left, right) + 1 : -1;	
    }
```



### 	111.	二叉树的最小深度

```java
public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = minDepth(root.left);
        int right = minDepth(root.right);
    //如果左孩子或由孩子其中一个为空则返回另一个孩子的深度并加上当前节点的深度(既+1)
    //否则返回两个非空孩子中的最小深度
        return root.left == null || root.right == null ? left + right + 1 : Math.min(left, right) + 1;    
        }
```



### 111.	二叉树寻找到叶子的路径

```java
public static boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        if (sum - root.val == 0){
            if (root.left == null && root.right == null){	//判断是否为叶子
                return true;
            }
        }
        return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);
    }
```

