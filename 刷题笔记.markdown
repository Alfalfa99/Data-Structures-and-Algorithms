# 								**LeetCode刷题记录**

## 数组

### 简单

#### 1.	两数之和

```java
//通过哈希表的键值存储数组的值和键进行比对
public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i], i);
        }
        for (int i = 0; i < nums.length; i++) {
            int number = target - nums[i];
            if (map.containsKey(number) && map.get(number)!= i){
                return new int[]{i,map.get(number)};
            }
        }
        throw new IllegalArgumentException(" ");
    }
```



#### 26.	删除数组中重复数

```java
public int removeDuplicates(int[] nums) {
        if (nums.length < 2) return nums.length;
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i]!=nums[j]){	//双指针移动
                j++;
                nums[j] = nums[i];
            }
        }
        return j+1;
    }
```





#### 27.	删除数组中指定数

```java
public int removeElement(int[] nums, int val) {
        if (nums.length == 0) {
            return 0;
        }
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != val) {	//如果遇到非目标数则填充数组
                nums[j++] = nums[i];
            }
        }
        return j + 1;
    }
```



#### 35.	搜索插入位置

```java
public int searchInsert(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i]>=target){		//如果数组当前位置的元素大于或等于目标数,直接返回或插入到当前位置
                return i;
            }
        }
        return nums.length;	//通过整个比对后还没发现位置则插入到数组末尾
    }
```



#### 66.	int数组加一

```java
public static int[] plusOne(int[] digits) {
        for (int i = digits.length - 1; i >= 0; i--) {
            if (digits[i] != 9) {	//从末尾开始如果有非9的位数就+1
                digits[i]++;
                return digits;
            }
            digits[i] = 0;	//为9的位数置零
        }
        digits = new int[digits.length + 1];	//最坏情况,整个数组都是9,需要添加一位
        digits[0] = 1;	//将第一位置1,其他位默认值为0
        return digits;
    }
```



#### 88.	合并两个有序数组

```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i,j;
        for (i = m - 1, j = n - 1; i >= 0 && j >= 0; ) {  //从后向前遍历两个数组,把大的数扔到num1的尾部
            if (nums1[i] > nums2[j]) {
                nums1[i + j + 1] = nums1[i];
                i--;
            } else {
                nums1[i + j + 1] = nums2[j];
                j--;
            }
        }
        while (j >= 0){	//如果nums2没有遍历完则将nums2剩余部分替代nums1的相应部分
            nums1[j] = nums2[j];
            j--;
        }
    }
```



#### 118.	杨辉三角前n行

```java
public List<List<Integer>> generate(int numRows) {
        ArrayList<List<Integer>> arrayList = new ArrayList<>();
        if (numRows == 0){
            return arrayList;
        }
        for (int i = 0; i < numRows; i++) {
            ArrayList<Integer> list = new ArrayList<>();
            for (int j = 0; j <= i; j++) {
                if (i == 0 || j == 0 || i == j){
                    list.add(1);
                } else {
                    list.add(arrayList.get(i-1).get(j-1)+arrayList.get(i-1).get(j));
                }
            }
            arrayList.add(list);
        }
        return arrayList;
    }
```



#### 119.	杨辉三角第n行

```java
public List<Integer> getRow(int rowIndex) {
    //从0行开始数,第n行有n+1个数
    //当n >=2 的时候开始执行内层循环,将数据置于第1~n位,首位和末尾直接设置为1
        List<Integer> cur = new ArrayList<>();
        cur.add(1);	
        for (int i = 1; i <= rowIndex; i++) {
            for (int j = i - 1; j > 0; j--) {
                cur.set(j, cur.get(j - 1) + cur.get(j));
            }
            cur.add(1);	//末尾设为1
        }
        return cur;
    }
```



#### 121.	求数组中的最大差值

```java
public int maxProfit(int[] prices) {
		//前提:只能是后边的数组元素减去前边的数组元素
        int minprice = Integer.MAX_VALUE;	//设置最小值
        int maxprofit = 0;	//设置最大利润
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minprice)
                minprice = prices[i];	//如果当前值小于最小值,更新最小值
            else if (prices[i] - minprice > maxprofit)	//如果当前值减去最小值大于当前最大利润	
                maxprofit = prices[i] - minprice;	//更新最大利润
        }
        return maxprofit;
    }
```





#### 122.	求数组中的差值之和

```java
//思路:如果当前项大于上一项,则总和增加为这两项的差值
public static int maxProfit(int[] prices) {
        int maxprofit = 0;
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i-1]){
                maxprofit += prices[i] - prices[i-1];
            }
        }
        return maxprofit;
    }
```





#### 136.	只出现一次的数字

```java
public static int singleNumber(int[] nums) {
        int ans = 0;
        for (int i = 0; i < nums.length; i++) {
            ans ^= nums[i];		//数组中每两个相同的数异或之后都为0,0与只出现过一次的数异或为该数
        }
        return ans;
    }
```





#### 167.	两数之和2

```java
//和两数之和1不同,本题为递增的数组,直接从两头开始找省时省事
public static int[] twoSum(int[] numbers, int target) {
        if (numbers.length == 0){
            throw new IllegalArgumentException("");
        }
        int i = 0, j = numbers.length-1;
        while (i<j){
            if (target > numbers[i] + numbers[j]){
                i++;
            }
            if (target < numbers[i] + numbers[j]){
                j--;
            }
            if (target == numbers[i] + numbers[j]){
                return new int[]{i+1,j+1};
            }
        }
        throw new IllegalArgumentException("");
    }
```



#### 169.	寻找数组中出现次数大于一半的数

```java
//解法1:候选人算法,如果当前候选人并非上次记录的候选人,则上次记录的候选人票数减一
public static int majorityElement(int[] nums) {
        int count = 0;
        int candidate = nums[0];
        for (int num : nums) {
            if (count == 0){
                candidate = num;
            }
            count += (candidate == num)? 1:-1;
        }
        return candidate;
}
//解法2:先进行排序,出现次数大于一半的数的位置一定会出现在nums.lenth/2
public static int majorityElement(int[] nums) {
	Arrays.sort(nums);
	return nums[nums.length/2];
}
```



### 中等



#### 54.	旋转数组

```java
public static List<Integer> spiralOrder(int[][] matrix) {
        if(matrix.length == 0) return new ArrayList<>();
        int l = 0, r = matrix[0].length - 1, t = 0, b = matrix.length - 1, x = 0;
        List<Integer> res = new ArrayList<>();
        while(true) {
            for(int i = l; i <= r; i++) res.add(matrix[t][i]); // left to right.
            if(++t > b) break;
            for(int i = t; i <= b; i++) res.add(matrix[i][r]); // top to bottom.
            if(l > --r) break;
            for(int i = r; i >= l; i--) res.add(matrix[b][i]); // right to left.
            if(t > --b) break;
            for(int i = b; i >= t; i--) res.add(matrix[i][l]); // bottom to top.
            if(++l > r) break;
        }
        return res;
    }
```



#### 240.	搜索二维矩阵

```java
//从二维数组的右上角开始找
public static boolean findNumberIn2DArray(int[][] matrix, int target) {
        int row = matrix.length;
        if (row == 0) {
            return false;
        }
        int col = matrix[0].length;
        if (col == 0) {
            return false;
        }
        int i = 0;
        int j = col - 1;
        while (i < row && j >= 0) {
            if (matrix[i][j] == target) {
                return true;
            }
            if (matrix[i][j] > target) {
                j--;
            } else {
                i++;
            }
        }
        return false;
    }
```



#### 153.	旋转数组的最小值

```java
public int findMin(int[] nums) {
        if (nums.length == 0){
            throw new IllegalArgumentException();
        }
        for(int i = 1; i < nums.length; i++){
            if (nums[i] < nums[i-1]){
                return nums[i];
            }
        }
        return nums[0];
    }
```







#### 560.	和为K的字数组

```java
public int subarraySum(int[] nums, int k) {
        int count = 0, pre = 0;
        HashMap<Integer, Integer> mp = new HashMap<>();
        mp.put(0, 1);
        for (int i = 0; i < nums.length; i++) {
            pre += nums[i];
            if (mp.containsKey(pre - k)) {
                count += mp.get(pre - k);
            }
            mp.put(pre, mp.getOrDefault(pre, 0) + 1);
        }
        return count;
    }
```





### 困难

#### 154.	旋转数组的最小值II

```java
//与153相同
public int minArray(int[] nums) {
        if (nums.length == 0){
            throw new IllegalArgumentException();
        }
        for(int i = 1; i < nums.length; i++){
            if (nums[i] < nums[i-1]){
                return nums[i];
            }
        }
        return nums[0];
    }
```





## 数字

### 简单

#### 7.	整数反转

```java
class Solution {
    public int reverse(int x) {
        int res = 0 ;
        while(x != 0){
            int temp = x % 10 + res * 10;
            //若发生溢出则下面该判断会为true,因为溢出后数字不确定,所以进行反操作不会获得原值
            if((temp - x % 10) / 10 != res){
                return 0 ;
            }
            res = temp ;
            x /= 10 ;
        }
        return res ;
    }
}
```



#### 9.	回文数

```java
//自己写的--思路:将整数反转后与原来的数字进行比较
class Solution {
    public boolean isPalindrome(int x) {
       int y = x;
        if (x < 0) {
            return false;
        }
        if (x == 0) {
            return true;
        }
        int res = 0;
        while (x != 0) {
            int temp = x % 10 + res * 10;
            res = temp;
            x /= 10;
        }
        if (y == res) {
            return true;
        } else {
            return false;
        }
    }
}

//参考答案--思路:只需判断前面一半的数字与后面一半的反转数字是否相同即可
class Solution {
    public boolean isPalindrome(int x) {
        if (x < 0 || (x % 10 == 0 && x != 0)) return false;	//末尾为0和小于0的数肯定为false
        int revertedNumber = 0;
        while (x > revertedNumber) {
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }
        return x == revertedNumber || x == revertedNumber / 10;	//分开讨论x为偶数和x为奇数的情况
    }
}

```

​																																		

#### 172.	阶乘后的零

```java
//纯数学题,淦!
public static int trailingZeroes(int n) {
        if (n < 5) {
            return 0;
        }
        int count = 0;
        while (n > 0) {
            n /= 5;
            count += n;
        }
        return count;
    }
```





#### 191.	二进制数中1的个数

```java
public static int hammingWeight(int n) {
        int  cnt = 0;
        while(n!=0){
            cnt++;
            n&=(n-1);
        }
        return cnt;
    }
```





### 中等

#### 50.	Pow(x,n)

```java
public static double myPow(double x, int n) {
        if (n == 0) {
            return 1.0;
        }
        return n > 0 ? helper(x, n) : 1.0 / helper(x, n);
    }

    public static double helper(double x, int M) {
        if (M == 0) {
            return 1.0;
        }
        double y = helper(x, M / 2);
        return M % 2 == 0 ? y * y : y * y * x;
    }
```



## 字符串

### 简单

#### 13.	罗马数字转整数

```java
/*个人代码,思路:
通过HashMap存储字符与值的对,再遍历字符数组如果后一位的值大于前一位的值则说明两个字符为一个数,否则一个字符一个数*/
public int romanToInt(String s) {
        char[] chars = s.toCharArray();
        HashMap<Character, Integer> map = new HashMap<>(7);
        map.put('I', 1);
        map.put('V', 5);
        map.put('X', 10);
        map.put('L', 50);
        map.put('C', 100);
        map.put('D', 500);
        map.put('M', 1000);
        int total = 0;
        if (chars.length == 1){
            total+=map.get(chars[0]);
            return total;
        }
        for (int i = 0; i < chars.length; i++) {
            if (i+1>=chars.length) {
                total+=map.get(chars[i]);
                break;
            }
            if (map.get(chars[i]) < map.get(chars[i+1])) {
                total += map.get(chars[i + 1]) - map.get(chars[i]);
                i++;
            } else {
                total += map.get(chars[i]);
            }
        }
        if (total > 3999 && total < 1){
            throw new IllegalArgumentException();
        }
        return total;
    }
```





#### 14.	最长公共前缀

```java
public String longestCommonPrefix(String[] strs) {
        //数组长度为0直接返回
        if (strs.length == 0) {
            return "";
        }
        //初始化公共前缀
        String prefix = strs[0];
        for (int i = 1; i < strs.length; i++) {
            //如果当前串与公共前缀不相等,进入while
            while(strs[i].indexOf(prefix) != 0) {
                //将公共前缀的最后一位删除
                prefix = prefix.substring(0, prefix.length() - 1);
                //如果公共前缀删除完毕仍未找到相同部分则返回
                if (prefix.equals("")) {
                    return "";
                }
            }
        }
        return prefix;
    }
```



#### 28.	实现strStr()

```java
public int strStr(String haystack, String needle) {	//找到haystack中的needle并返回首次出现的位置
        return haystack.indexOf(needle);
    }
```



#### 38.	外观数列(说数)

```java
/**
	1.     1
	2.     11
	3.     21
	4.     1211
	5.     111221
	其实思路就在于每一步都把上一步的数说出来,n=2就说有1个1,n=3就说2个1,n=4就说1个2和1个1
**/

public static String countAndSay(int n) {
        String start = "1";
        return run(start, n - 1);
    }

    public static String run(String s, int time) {
        if (time == 0) {
            return s;
        }
        int n = s.length();
        StringBuilder sb = new StringBuilder();
        int count = 1;
        char c = s.charAt(0);
        for (int i = 1; i < n; i++) {
            if (s.charAt(i) == s.charAt(i - 1)) {
                count++;
            } else {
                sb.append(count);
                sb.append(s.charAt(i - 1));
                count = 1;
            }
        }
        sb.append(count);
        sb.append(s.charAt(n - 1));
        return run(sb.toString(), time - 1);
    }
```



#### 58.	最后一个单词的长度

```java
public static int lengthOfLastWord(String s) {
        char[] chars = s.trim().toCharArray();  //调用.trim()方法删除字符串首末的空格
        if(chars.length == 0){  //如果删除了空格之后的字符串长度为空则返回
            return 0;
        }
        for(int i = chars.length -1; i >=0; i --){  
            if(chars[i] == ' ' ){   //从尾往前,如果遇到空格则说明最后一个字符串找完了
                return chars.length-1-i;    //返回长度-空格的位置-1
            }
            if(i == 0){ //没有找到空格,说明全都是一个单词
                return chars.length;    //返回长度
            }
        }
        return 0;
    }
```



#### 67.	两个二进制数求和

```java
public static String addBinary(String a, String b) {
        int ca = 0;
        StringBuilder sb = new StringBuilder();
        for (int i = a.length() - 1, j = b.length() - 1; i >= 0 || j >= 0; i--, j--) {
            int sum = ca;
            sum += i >= 0 ? a.charAt(i) - '0' : 0;   //如果串a读完了就自动补0
            sum += j >= 0 ? b.charAt(j) - '0' : 0;   //如果串b读完了就自动补0;
            sb.append(sum % 2);                     //当前位置的数是否超过1,如果超过就取余
            ca = sum / 2;                           //把超过1的数作为余数放入下一位的运算
        }
        sb.append(ca == 1 ? ca : "");   //循环结束后还有进位数则最后填1
        return sb.reverse().toString(); //将字符串反转获得目标串,因为我们是从小位开始填充的
    }
```

​		

#### 125.	验证回文字符串

```java
public static boolean isPalindrome(String s) {
        if (s == null){
            return true;
        }
        if (s.length() == 0){
            return true;
        }
        s = s.toLowerCase();
        for (int i = 0,j = s.length()-1; i != j;) {
            if ((s.charAt(i) >= 'a' && s.charAt(i) <= 'z') || (s.charAt(i) >= '0' && s.charAt(i)<= '9')){
                if (s.charAt(j) >= 'a' && s.charAt(j) <= 'z' || s.charAt(j) >= '0' && s.charAt(j)<= '9'){
                    if (s.charAt(i) == s.charAt(j)){
                        j--;
                        i++;
                        continue;
                    }
                    return false;
                } else {
                    j--;
                }
            } else {
                i++;
            }
        }
        return true;
    }
```





#### 168.	进制问题

```java
//本题'A' = 1 ,'B' = 2,由于'Z' = 'A' + 25 , n = 26时输出'Z',所以我们要对n-1才能在取余之后获取正确的数值

public static String convertToTitle(int n) {
        StringBuilder stringBuilder = new StringBuilder();
        while (n != 0) {
            n --;//这里稍作处理，因为它是从1开始
            stringBuilder.insert(0,(char)(n % 26 + 'A'));
            n /= 26;
        }
        return stringBuilder.toString();
    }
```



#### 171.	进制问题2

```java
//从字母转回数字,26进制转10进制
public static int titleToNumber(String s) {
        if (s == null || s == ""){
            return -1;
        }
        int total = 0;
        for (int i = 0; i < s.length(); i++) {
            total = s.charAt(i) - 64 + total*26;
        }
        return total;
    }
```





#### 680.	验证回文字符串2

```java
public static boolean validPalindrome(String s) {
        for (int i = 0, j = s.length() - 1; i < j; i++, j--) {
            if (s.charAt(i) == s.charAt(j)) {
                continue;
            } else {
                return DFS(s.substring(i+1,j+1)) || DFS(s.substring(i,j));
            }
        }
        return true;
    }

    public static boolean DFS(String s) {
        for (int i = 0, j = s.length()-1; i < j; i++,j--) {
            if (s.charAt(i) == s.charAt(j)){
                continue;
            } else {
                return false;
            }
        }
        return true;
    }
```





### 中等

#### 65.	表示数字的字符串

```java
20.	表示数字的字符串

    public boolean isNumber(String s) {
            if(s == null || s.length() == 0){
                return false;
            }
            //标记是否遇到相应情况
            boolean numSeen = false;
            boolean dotSeen = false;
            boolean eSeen = false;
            char[] str = s.trim().toCharArray();
            for(int i = 0;i < str.length; i++){
                if(str[i] >= '0' && str[i] <= '9'){
                    numSeen = true;
                }else if(str[i] == '.'){
                    //.之前不能出现.或者e
                    if(dotSeen || eSeen){
                        return false;
                    }
                    dotSeen = true;
                }else if(str[i] == 'e' || str[i] == 'E'){
                    //e之前不能出现e，必须出现数
                    if(eSeen || !numSeen){
                        return false;
                    }
                    eSeen = true;
                    numSeen = false;//重置numSeen，排除123e或者123e+的情况,确保e之后也出现数
                }else if(str[i] == '-' || str[i] == '+'){
                    //+-出现在0位置或者e/E的后面第一个位置才是合法的
                    if(i != 0 && str[i-1] != 'e' && str[i-1] != 'E'){
                        return false;
                    }
                }else{//其他不合法字符
                    return false;
                }
            }
            return numSeen;
        }



```





## 栈

### 简单

#### 20.	括号匹配(栈)

```java
public static boolean isValid(String s) {
        if (s.length() == 0) {
            return true;
        }
        if ((s.length() & 1) == 1) {
            return false;
        }
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            switch (s.charAt(i)) {
                case '(':
                case '[':
                case '{':
                    stack.push(s.charAt(i));
                    continue;
                case ')':
                    if (stack.isEmpty() || stack.pop() != '(') {
                        return false;
                    }
                    continue;
                case ']':
                    if (stack.isEmpty() || stack.pop() != '[') {
                        return false;
                    }
                    continue;
                case '}':
                    if (stack.isEmpty() || stack.pop() != '{') {
                        return false;
                    }
                    continue;
            }
        }
        return stack.isEmpty();
    }
```



#### 155.	最小栈

```java
class MinStack {
		Stack<Integer> stack;
        int min;
        /** initialize your data structure here. */
        public MinStack() {
            stack = new Stack();
            min = Integer.MAX_VALUE;
        }

        public void push(int x) {
            if(min >= x){
                stack.push(min);
                min = x;
            }
            stack.push(x);
        }

        public void pop() {
            if(min == stack.pop()){
                min = stack.pop();
            }
        }

        public int top() {
            return stack.peek();
        }

        public int getMin() {
            return min;
        }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```





## 链表

### 简单

#### 21.	合并两个升序链表

```java
    public class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }
//通过递归写法
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {//当某一链表没有节点后直接返回另一个链表即可
            return l2;
        }
        if (l2 == null) {
            return l1;
        }
        if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);	//  l1的当前节点被使用过,将l1的下一节点继续放入递归
            return l1;	//return l1 相当于把链表中的箭头指向l1中第一个未使用的节点
        } else {
            l2.next = mergeTwoLists(l1, l2.next);	//	l2的当前节点被使用过,将l2的下一节点继续放入递归
            return l2;	//return l2 相当于把链表中的箭头指向l2中第一个未使用的节点
        }
    }

```



#### 83.	删除链表中的重复元素

```java
public ListNode deleteDuplicates(ListNode head) {
        ListNode p = head;
        while (p!= null && p.next != null){
            if (p.val == p.next.val){
                p.next = p.next.next;
            } else {
                p = p.next;
            }
        }
        return head;
    }
```





#### 141.	环形链表

```java
//思路:利用快慢指针进行判断
//如果为环形链表快指针一定会追上慢指针(套一圈)
//如果快指针到尾则说明不是环形链表;
public static boolean hasCycle(ListNode head) {
       if (head == null || head.next == null) {
            return false;
        }
        ListNode p1 = head.next;
        ListNode p2 = head;
        while (p1 != null && p1.next != null) {	//不能写反条件,否则会出错
            if (p1 == p2) {
                return true;
            }
            p1 = p1.next.next;
            p2 = p2.next;
        }
        return false;
    }
```



#### 160.	相交链表

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        ListNode p1 = headA,p2 = headB;
        while (p1 != p2) {	//让p1,p2两个指针都遍历完两根链表,如果有相交的部分,则p1一定等于p2
            p1 = p1 == null?headB:p1.next;
            p2 = p2 == null?headA:p2.next;
        }
        return p1;
    }
```





#### 206.	反转链表

```java
public static ListNode reverseList(ListNode head) {
        if (head == null){
            return null;
        } else if (head.next == null){
            return head;
        }
        return helper(head,head.next,null);
    }

    public static ListNode helper(ListNode p1, ListNode p2,ListNode tail){
        if (p2.next != null) {
            tail = helper(p2, p2.next,null);
            p2.next = p1;
        }else {
            p2.next = p1;
            tail = p2;
            p1.next = null;
            return tail;
        }
        p1.next = null;
        return tail;
    }
```





### 困难

#### 25.	k个一组反转链表

```java
public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        ListNode pre = dummy;
        ListNode end = dummy;

        while (end.next != null) {
            for (int i = 0; i < k && end != null; i++){
                end = end.next;
            }
            if (end == null) {
                break;
            }
            ListNode start = pre.next;
            ListNode next = end.next;
            end.next = null;
            pre.next = reverse(start);
            start.next = next;
            pre = start;

            end = pre;
        }
        return dummy.next;
    }

    private ListNode reverse(ListNode head) {
        ListNode pre = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode next = curr.next;
            curr.next = pre;
            pre = curr;
            curr = next;
        }
        return pre;
    }
```







## 动态规划



### 5.	最长回文子串

```java
	/**
     * s = "abcda"
     *
     *  0 1 2 3 4 j
     * 0 T
     * 1 F T
     * 2 F F T
     * 3 F F F T
     * 4 F F F F T
     * i
     * 注意(4,0)虽然s.charAt(4) = s.charAt(0),但不能使dp[i][j] = true
     * 原因:你不能因为首末两个字母相等就说他是回文串,你要从之前的状态dp[i-1][j+1]中进行查询
     * 如果dp[i-1][j+1] == true的话及说明之前的这个子串也是回文串,直接进行子串增长操作即可
     */
    public static String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }
        Boolean[][] dp = new Boolean[len][len];
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }
        int MaxLen = 1;
        int Start = 0;

        for (int i = 1; i < len; i++) {
            for (int j = 0; j < i; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    if (i - j < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i - 1][j + 1];
                    }
                } else {
                    dp[i][j] = false;
                }
                if (dp[i][j]) {
                    int CurLen = i - j + 1;
                    if (CurLen > MaxLen) {
                        Start = j;
                        MaxLen = CurLen;
                    }
                }
            }
        }
        return s.substring(Start, Start + MaxLen);
    }
```







### 53.	最大子序和(动态规划--Kadane算法)

```java
public int maxSubArray(int[] nums) {
        int Sum = nums[0];
        for (int i = 1; i < nums.length; i++) {	//从1开始
            if (nums[i - 1] > 0) {	//如果第i-1项大于零那就加到当前项上
                nums[i] = nums[i] + nums[i - 1];	//将上一项加到这一项
            }
            Sum = Math.max(nums[i],Sum);	//判断是当前项大还是之前存储的数大
        }
        return Sum;
    }
```

​				

### 62.	不同路径

```java
public static int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                //当在数组的最上一行或最左一列时,只能由上一格向右或向下走一步而得,只有一种可能性.
                if (i == 0 || j == 0){	
                    dp[i][j] = 1;
                } else {
                    dp[i][j] = dp[i-1][j]+dp[i][j-1];
                }
            }
        }
        return dp[m-1][n-1];
    }
```



​																																			

### 70.	爬楼梯(递推型DP)

```java
public static int climbStairs(int n) {
        if (n == 1){
            return 1;
        }
        //动态规划,达到最后一层楼梯的两种可能,一种是从n-1走到n,另一种是从n-2走到n
        int[] num = new int[n+1];   //num[0]不使用
        num[1] = 1; //走到第一层只有一种走法
        num[2] = 2; //走到第二层有两种走法
        for (int i = 3; i < n + 1; i++) {
            num[i] = num[i-1]+num[i-2]; //在第n层有num[i-1]  + num[i-2]种走法
        }
        return num[n];//数组中存的每个数就代表走到该层楼的方法数量
    }
```



### 509.	第N个斐波那契数(递推型DP)

```java
public static int fib(int N) {
        int[] dp = new int[N+1];
        if (N <= 1){
            return N;
        }
        dp[0] = 0;
        dp[1] = 1;

        for (int i = 2; i <= N; i++) {
            dp[i] = dp[i-1]+dp[i-2];
        }
        return dp[N];
    }
```



### 1137.	第N个三波那契数(递推型DP)

```java
public static int tribonacci(int n) {
        int[] dp = new int[n+1];
        if (n <= 1){
            return n;
        } else if (n == 2){
            return 1;
        }
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 1;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i-3]+dp[i-2]+dp[i-1];
        }
        return dp[n];
    }
```







### 72.	编辑距离

```java
//本题可以这样看,如果增加字母则往下走,如果删除字母则往右走,如果替换则在左,左上,上三个元素中取最小+1
//若两个字母相等则不做处理
/* word1 = "cbd"
 * word2 = "cat"
 *
 *	0	1	2	3
 *	1	0	1	2
 *	2	1	1	2
 *	3	2	2	2
 */
public static int minDistance(String word1, String word2) {
        int l1 = word1.length();
        int l2 = word2.length();
        if (l1 * l2 == 0) {
            return l1+l2;
        }
        int[][] dp = new int[l1+1][l2+1];
        for (int i = 0; i < l1 + 1; i++) {
            dp[i][0] = i;
        }
        for (int i = 0; i < l2 + 1; i++) {
            dp[0][i] = i;
        }
        for (int i = 1; i <= l1; i++) {
            for (int j = 1; j <= l2; j++) {
                if (word1.charAt(i-1) == word2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1];  //左上角的坐里的步数一定是(左,左上,上)三者里最小的数(或之一)
                } else {
                    //从dp[i-1][j],dp[i-1][j-1],dp[i][j-1]里边选取最小的加1
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]),dp[i-1][j-1]) + 1;
                }
            }
        }
        return dp[l1][l2];
    }
```



### 91.	解码方法

```java
public static int numDecodings(String s) {
        int len = s.length();

        int help = 1;
        int res = 0;
        //从s的尾部开始向前遍历,如果尾部不是0则肯定有一种可能性
        if (s.charAt(len - 1) != '0') {
            res = 1;
        }
        for (int i = len - 2; i >= 0; i--) {
            if (s.charAt(i) == '0') {
                help = res;
                res = 0;
                continue;
            }
            if ((s.charAt(i) - '0') * 10 + (s.charAt(i + 1) - '0') <= 26) {
                res += help;
                //help用来存储res以前的值
                help = res-help;
            } else {
                help = res;
                //若两者都为0说明有一位为0,他的前一位大于2,既超出了26的范围,导致该0成为孤儿,所以该数肯定是错的,返回0
                if (help == 0){
                    return 0;
                }
            }

        }
        return res;
    }
```



### 95.	不同的二叉搜索树2

```java
public List<TreeNode> generateTrees(int n) {
        List<TreeNode>[] dp = new ArrayList[n+1];
        dp[0] = new ArrayList(); // 如果left或right为0，就会出现空指针异常。
        if (n == 0) return dp[0];
        dp[0].add(null);// 如果不加null，那么后面当left或right为0时，就不会执行for循环。而一旦left不执行，right也会被跳过。
        for (int i = 1; i <= n; i++) {
            dp[i] = new ArrayList();
            for (int root = 1; root <= i; root++) {
                int left = root - 1; // root为根节点，left是root左边的节点数。
                int right = i - root;// 同理，right为root右边的节点数。
                /*
                    假设n为5，root是3，那么左边有2个节点，所以去dp[2]里面找，右边也有两个节点4,5。所以还去dp[2]里面找。
                    因为只有dp[2]里面都是2个节点的数。但是dp[2]中的数只有1和2，我们要的是4,5。
                    我们不妨将1,2加上root，你会发现正好是4,5。
                    所以得到结论，左子树的值直接找前面节点数一样的dp索引，右子树的值也找前面一样的dp索引,
                    但是你需要加上root才能保证val是你需要的，所以右子树要重新创建，不然会破坏前面的树。
                */
                // 如果dp[left]里有两种可能，dp[right]里有三种可能，那么总共有6种可能。
                for (TreeNode leftTree : dp[left]) {
                    for (TreeNode rightTree : dp[right]) {
                        TreeNode newRoot = new TreeNode(root); // 这个是每一种可能的root节点。
                        newRoot.left = leftTree; // 左子树直接连接。
                        newRoot.right = clone(root, rightTree); // 右子树创建一个新的树。
                        dp[i].add(newRoot); // 将一种可能加入dp中。
                    }
                }
            }
        }
        return dp[n]; // 这个不用多说，答案在第n个数上。
    }
    
    public TreeNode clone(int val, TreeNode root) { // 重新创建一个新的子树
        if (root == null) return null; // 如果为null，返回
        TreeNode newTree = new TreeNode(val + root.val); // 创建节点时，不要忘了还要加上那个root。
        newTree.left = clone(val, root.left); // 递归左和右，和先序遍历很像。
        newTree.right = clone(val, root.right);
        return newTree; // 返回回去的这个节点正好跟在你需要的右子树上。
    }
```



### 96.	不同的二叉搜索树

```java
public static int numTrees(int n) {
        //卡特兰数 Cn = 2(2n+1)*Cn-1/(n+2)
        long C = 1;
        for (int i = 0; i < n; ++i) {
            C = C * 2 * (2 * i + 1)/(i + 2);
        }
        return (int)C;
    }
```







### 120.	三角形最小路径和

```java
public static int minimumTotal(List<List<Integer>> triangle) {
        int size = triangle.size();
        int[][] dp = new int[size][size];
        if (triangle == null || size == 0){
            return 0;
        }
        //初始化
        for (int i = 0; i < triangle.get(size-1).size(); i++) {
            dp[size-1][i] = triangle.get(size-1).get(i);
        }
        //自底向上,第i行第j个数加上第i+1行的(第j个数和第j+1个数的最小值)即为当前位置的最短路径
        for (int i = size-2; i >= 0; i--) {
            for (int j = 0; j <= i; j++) {
                dp[i][j] = triangle.get(i).get(j)+Math.min(dp[i+1][j],dp[i+1][j+1]);
            }
        }
        return dp[0][0];
    }
```





### 139.	单词拆分

```java
public static boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp = new boolean[s.length() + 1];
        //初始化,因为空串总是字典的一部分
        dp[0] = true;
        //下标i用来表示从当前字符串开始的可能的子字符串
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && wordDict.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
```



### 300.	最长上升子序列(线性DP LIS)

```java
public static int lengthOfLIS(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        // dp[]表示i个数最长子序列的长度
        int[] dp = new int[nums.length];
        //初始化整个数组都为1,因为数组中每个数都是自己的子序列,长度为1
        for (int i = 0; i < nums.length; i++) {
            dp[i] = 1;
        }
        //记录最长的子序列长度
        int max = dp[0];
        //画表格
        for (int i = 0; i < nums.length - 1; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                //从i+1开始找,如果找到一个数j,使得nums[j] > num[i],则让dp[j] = dp[i] + 1;
                //但这里有一个问题,如果当前dp[j]作为别的子序列的长度大于当前子序列长度的话,使用最长子序列的长度
                //所以状态转移方程为: dp[j] = Math.max(dp[i]+1,dp[j]);
                //如果dp[j]>max,更新max的值
                if (nums[j] > nums[i]) {
                    dp[j] = Math.max(dp[i] + 1, dp[j]);
                    if (dp[j] > max) {
                        max = dp[j];
                    }
                }
            }
        }
        return max;
    }
```



### 1143.	最长公共子序列(LCS)

```java
public static int longestCommonSubsequence(String text1, String text2) {
        char[] t1 = text1.toCharArray();
        char[] t2 = text2.toCharArray();
        int len1 = t1.length;
        int len2 = t2.length;
        int[][] dp = new int[len1+1][len2+1];
        for(int i = 1; i <= len1; i++) {
            for(int j = 1; j <= len2; j++) {
                dp[i][j] = t1[i-1] == t2[j-1] ? (dp[i-1][j-1] + 1) : Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
        return dp[len1][len2];
    }
```









### 322.	零钱兑换(完全背包)

```java
public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp,amount+1);
        dp[0] = 0;

        for (int coin : coins) {
            for (int i = coin; i <= amount ; i++) {
                dp[i] = Math.min(dp[i],dp[i-coin]+1);
            }
        }

        if (dp[amount] == amount +1){
            dp[amount] = -1;
        }
        return dp[amount];
    }
```



### 518.	零钱兑换2(完全背包)

```java
public static int change(int amount, int[] coins) {
        int[][] dp = new int[coins.length][amount+1];
        dp[0][0] = 1;
        for (int i = coins[0]; i <= amount; i++) {
            dp[0][i] = dp[0][i-coins[0]];
        }

        for (int i = 1; i < coins.length; i++) {
            for (int j = 0; j <= amount; j++) {
                dp[i][j] = dp[i-1][j];
                if (j >= coins[i]){
                    dp[i][j] = dp[i-1][j] + dp[i][j-coins[i]];
                }
            }
        }
        return dp[coins.length-1][amount];

        /**
         * 压缩后
         * int[] dp = new int[amount + 1];
         *         dp[0] = 1;
         *
         *         for (int coin : coins) {
         *             for (int x = coin; x < amount + 1; ++x) {
         *                 dp[x] += dp[x - coin];
         *             }
         *         }
         *         return dp[amount];
         */
    }
```





### 416.	分割等和子集(01背包 )

```java
public static boolean canPartition(int[] nums) {
        if(nums.length == 0){
            return false;
        }
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
        }
        if (sum % 2 != 0) {
            return false;
        }
        int target = sum / 2;
        boolean[][] dp = new boolean[nums.length][target + 1];
        //初始化
        if (nums[0] <= target) {
            dp[0][nums[0]] = true;
        }

        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j <= target; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j == nums[i]) {
                    dp[i][j] = true;
                    continue;
                }
                if (nums[i] < j) {
                    dp[i][j] = dp[i - 1][j - nums[i]] || dp[i - 1][j];
                }
            }
        }
        return dp[nums.length - 1][target];
    }
```



### 494.	目标和(01背包)

```java
public static int findTargetSumWays(int[] nums, int S) {
        int sum = 0;
        //
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
        }
        if (Math.abs(S) > sum) {
            return 0;
        }
        int border = sum * 2 + 1;
        int[][] dp = new int[nums.length][border];
        //初始化
        if (nums[0] == 0) {
            dp[0][sum] = 2;
        } else {
            dp[0][sum - nums[0]] = 1;
            dp[0][sum + nums[0]] = 1;
        }

        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < border; j++) {
                int l = j - nums[i] >= 0 ? j - nums[i] : 0;
                int r = j + nums[i] < border ? j + nums[i] : 0;
                dp[i][j] = dp[i-1][r]+dp[i-1][l];
            }
        }
        return dp[nums.length-1][S+sum];
    }
```



### 343. 	整数拆分

```java
public int integerBreak(int n) {
        int[] dp = new int[n+1];
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i / 2; j++) {
                dp[i] = Math.max(Math.max(j*(i-j),dp[i-j]*j),dp[i]);
            }
        }
        return dp[n];
    }
```





## 查找

### 折半查找																																						

#### 69.	x的平方根

```java
public static int mySqrt(int x) {
        if (x < 2) {
            return x;
        }
        long num;
        int pos, left = 2, right = x / 2;
        while (left <= right) {
            pos = (left + right) / 2;
            num = (long) pos * pos;
            if (num < x) {
                left = pos + 1;
            } else if (num > x) {
                right = pos - 1;
            } else {
                return pos;
            }
        }
        return right;
    }
```



### 二分查找

#### 4.	寻找两个有序数组的中位数

```java
//寻找两个数组的中位数进行比较,中位数较小的那个数组将中位数左边的数丢掉,中位数较大的那个数组将中位数右边的数丢掉,反复比对
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int m = nums2.length;
        int left = (n + m + 1) / 2;
        int right = (n + m + 2) / 2;
        //将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。
        return (getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) + getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)) * 0.5;
    }
		
    private static int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) {
        int len1 = end1 - start1 + 1;
        int len2 = end2 - start2 + 1;
        //让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1
        if (len1 > len2){
            return getKth(nums2, start2, end2, nums1, start1, end1, k);
        }
        if (len1 == 0){
            return nums2[start2 + k - 1];
        }

        if (k == 1){
            return Math.min(nums1[start1], nums2[start2]);
        }

        int i = start1 + Math.min(len1, k / 2) - 1;
        int j = start2 + Math.min(len2, k / 2) - 1;

        if (nums1[i] > nums2[j]) {
            return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));
        }
        else {
            return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));
        }
    }
```



## 树																																			

### 100.	相同的树(树)

```java
public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int x) {
            val = x;
        }
    }

    public static boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) return true;    //如果当前的节点都为null则为true,返回递归上一层
        if (p == null || q == null) return false;   //如果只有一个为null则不同
        if (p.val != q.val) return false;           //如果值不同则不同
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);//将两棵树都放入递归
    }
```



### 101.	对称的树 (树)

```java
public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int x) {
            val = x;
        }
    }

    public static boolean isSymmetric(TreeNode root) {
        if (root == null){
            return true;
        }
        return degui(root.left,root.right);
    }

    public static Boolean degui(TreeNode l, TreeNode r) {
        if (l == null && r == null) {
            return true;
        }
        if (l == null || r == null) {
            return false;
        }
        if (l.val == r.val){
            return degui(l.left,r.right) && degui(l.right,r.left);
        } else {
            return false;
        }
    }
```



### 102.	二叉树的层序遍历

```java
public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null){
            return new LinkedList<>();
        }
        List<List<Integer>> lists = new LinkedList<>();
        Queue<TreeNode> queue = new ArrayDeque<>();
        queue.add(root);
        while (!queue.isEmpty()){
            LinkedList<Integer> linkedList = new LinkedList<>();
            int length = queue.size();
            for (int i = 0; i < length; i++) {
                TreeNode treeNode = queue.poll();
                linkedList.add(treeNode.val);
                if (treeNode.left != null){
                    queue.add(treeNode.left);
                }
                if (treeNode.right != null){
                    queue.add(treeNode.right);
                }
            }
            lists.add(linkedList);
        }
        return lists;
    }
```





### 103.	奇偶层序遍历二叉树

```java
public static List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> lists = new LinkedList<>();
        if (root == null) {
            return lists;
        }
        Stack<TreeNode> stack1 = new Stack<>();
        Stack<TreeNode> stack2 = new Stack<>();

        stack1.push(root);
        boolean flag = true;
        while (!stack1.isEmpty() || !stack2.isEmpty()) {
            List<Integer> list = new LinkedList<>();
            if (flag) {
                while (!stack1.isEmpty()) {
                    TreeNode treeNode = stack1.pop();
                    list.add(treeNode.val);
                    if (treeNode.left != null) {
                        stack2.push(treeNode.left);
                    }
                    if (treeNode.right != null) {
                        stack2.push(treeNode.right);
                    }
                }
                lists.add(list);
            } else {
                while (!stack2.isEmpty()) {
                    TreeNode treeNode = stack2.pop();
                    list.add(treeNode.val);
                    if (treeNode.right!=null){
                        stack1.push(treeNode.right);
                    }
                    if (treeNode.left != null) {
                        stack1.push(treeNode.left);
                    }
                }
                lists.add(list);
            }
            flag = !flag;
        }
        return lists;
    }
```







### 108.	将有序数组转化为二叉搜索树

```java
int nums[];

    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums.length == 0) {
            return null;
        }
        this.nums = nums;
        return degui(0, nums.length - 1);
    }

//思路:利用分治的思想将整个数组分半,第一次找到的节点即为根节点,从左边找到的第一个节点为根节点的左孩子,右边同理
    public TreeNode degui(int left, int right) {
        if (left > right){
            return null;
        }
        int mid = (left + right) / 2;
        TreeNode treeNode = new TreeNode(this.nums[mid]);
        treeNode.left = degui(left,mid-1);	
        treeNode.right = degui(mid+1,right);
        return treeNode;
    }
```



### 108.	平衡二叉树

```java
public boolean isBalanced(TreeNode root) {
        return degui(root) != -1;
    }

    public static int degui(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = degui(root.left);	//将左子树放入递归
        if (left == -1) {	//如果某个左子树发现不平衡直接返回-1
            return -1;
        }
        int right = degui(root.right);	//将右子树放入递归
        if (right == -1) {	//如果某个右子树发现不平衡直接返回-1
            return -1;
        }
        //如果当前节点的左右子树平衡的话返回当前子树的高度并加上当前节点,否则说明不平衡返回-1
        return Math.abs(left - right) < 2 ? Math.max(left, right) + 1 : -1;	
    }
```



### 	111.	二叉树的最小深度

```java
public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = minDepth(root.left);
        int right = minDepth(root.right);
    //如果左孩子或由孩子其中一个为空则返回另一个孩子的深度并加上当前节点的深度(既+1)
    //否则返回两个非空孩子中的最小深度
        return root.left == null || root.right == null ? left + right + 1 : Math.min(left, right) + 1;    
        }
```



### 111.	二叉树寻找到叶子的路径

```java
public static boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        if (sum - root.val == 0){
            if (root.left == null && root.right == null){	//判断是否为叶子
                return true;
            }
        }
        return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);
    }
```





### 113.	二叉树中到叶子节点的路径之和

```java
public static List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> lists = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        if (root == null) {
            return lists;
        }
        helper(lists, list, root, sum);
        return lists;
    }

    public static List<Integer> helper(List<List<Integer>> lists, List<Integer> list, TreeNode root, int sum) {
        if (root == null) {
            return list;
        }
        list.add(root.val);
        if (sum != root.val || root.left !=null || root.right != null) {
            list = helper(lists, list, root.left, sum-root.val);
            list = helper(lists, list, root.right, sum-root.val);
        }
        if (sum == root.val && root.left == null && root.right == null) {
            List<Integer> list1 = new ArrayList<>();
            for (int i = 0; i < list.size(); i++) {
                list1.add(list.get(i));
            }
            lists.add(list1);
            list.remove(list.size() - 1);
            return list;
        }
        list.remove(list.size()-1);
        return list;
    }
```







### 105.	通过先序遍历和中序遍历创建二叉树

```java
// 使用全局变量是为了让递归方法少传一些参数，不一定非要这么做

    private Map<Integer, Integer> reverses;
    private int[] preorder;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int preLen = preorder.length;
        int inLen = inorder.length;

        // 可以不做判断，因为题目中给出的数据都是有效的
        if (preLen != inLen) {
            return null;
        }

        this.preorder = preorder;

        // 以空间换时间，否则，找根结点在中序遍历中的位置需要遍历
        reverses = new HashMap<>(inLen);
        for (int i = 0; i < inLen; i++) {
            reverses.put(inorder[i], i);
        }

        return buildTree(0, preLen - 1, 0, inLen - 1);
    }

    /**
     * 根据前序遍历数组的 [preL, preR] 和 中序遍历数组的 [inL, inR] 重新组建二叉树
     *
     * @param preL 前序遍历数组的区间左端点
     * @param preR 前序遍历数组的区间右端点
     * @param inL  中序遍历数组的区间左端点
     * @param inR  中序遍历数组的区间右端点
     * @return 构建的新二叉树的根结点
     */
    private TreeNode buildTree(int preL, int preR,
                               int inL, int inR) {
        if (preL > preR || inL > inR) {
            return null;
        }
        // 构建的新二叉树的根结点一定是前序遍历数组的第 1 个元素
        int pivot = preorder[preL];
        TreeNode root = new TreeNode(pivot);

        int pivotIndex = reverses.get(pivot);

        // 这一步得画草稿，计算边界的取值，必要时需要解方程，并不难
        root.left = buildTree(preL + 1, preL + (pivotIndex - inL), inL, pivotIndex - 1);
        root.right = buildTree(preL + (pivotIndex - inL) + 1, preR, pivotIndex + 1, inR);
        return root;
    }
```



### 124.	二叉树的最大路径和

```java
static int max_num = Integer.MIN_VALUE;
    public static int maxPathSum(TreeNode root) {
        DFS(root);
        return max_num;
    }

    public static int DFS(TreeNode root){
        if (root == null){
            return 0;
        }
        //如果左子树是负的或右子树是负的就不选
        int leftVal = Math.max(DFS(root.left),0);
        int rightVal = Math.max(DFS(root.right),0);
        max_num = Math.max(max_num,leftVal+root.val+rightVal);
        return root.val+Math.max(leftVal,rightVal);
    }
```





### 226.	二叉树的镜像

```java
public TreeNode mirrorTree(TreeNode root) {
        TreeNode nroot = null;
        return helper(root,nroot);
    }
    public static TreeNode helper(TreeNode root, TreeNode nroot){
        if (root == null){
            return null;
        }
        nroot = new TreeNode(root.val);
        nroot.right = helper(root.left,nroot.right);
        nroot.left = helper(root.right,nroot.left);
        return nroot;
    }
```



### 297.	序列化二叉树

```java
public static String serialize(TreeNode root) {
        return helpSerialize(root, "");
    }

    public static String helpSerialize(TreeNode root, String str){
        if (root == null){
            str+="null,";
            return str;
        } else{
            str += root.val+",";
            str = helpSerialize(root.left,str);
            str = helpSerialize(root.right,str);
        }
        return str;
    }
    // Decodes your encoded data to tree.
    public static TreeNode deserialize(String data) {
        String[] StrData = data.split(",");
        List<String> list = new LinkedList<>(Arrays.asList(StrData));
        return buildTree(list);
    }

    public static TreeNode buildTree(List<String> list){
        if (list.get(0).equals("null")){
            list.remove(0);
            return null;
        }
        TreeNode root = new TreeNode(Integer.valueOf(list.get(0)));
        list.remove(0);
        root.left = buildTree(list);
        root.right = buildTree(list);
        return root;
    }
```









## 搜索

### bfs

#### 79.	单词搜索

```java
public boolean exist(char[][] board, String word) {
        char[] w = word.toCharArray();
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (bfs(board,w,i,j,0)){
                    return true;
                }
            }
        }
        return false;
    }

    public static boolean bfs(char[][] board, char[] w, int i, int j, int k) {
        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || w[k] != board[i][j]) {
            return false;
        }
        if (k == w.length - 1) {
            return true;
        }
        char tmp = board[i][j];
        board[i][j] = '/';
        boolean res = bfs(board, w, i - 1, j, k + 1) || bfs(board, w, i + 1, j, k + 1) ||
                bfs(board, w, i, j + 1, k + 1) || bfs(board, w, i, j - 1, k + 1);
        board[i][j] = tmp;
        return res;
    }
```



#### 210.	课程表2(拓补排序)

```java
public static int[] findOrder(int numCourses, int[][] prerequisites) {
        if (numCourses == 0) return new int[0];
        int[] inDegrees = new int[numCourses];
        // 建立入度表
        for (int[] p : prerequisites) { // 对于有先修课的课程，计算有几门先修课
            inDegrees[p[0]]++;
        }
        // 入度为0的节点队列
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < inDegrees.length; i++) {
            if (inDegrees[i] == 0) {
                queue.offer(i);
            }
        }
        int count = 0;  // 记录可以学完的课程数量
        int[] res = new int[numCourses];  // 可以学完的课程
        // 根据提供的先修课列表，删除入度为 0 的节点
        while (!queue.isEmpty()){
            int curr = queue.poll();
            res[count++] = curr;   // 将可以学完的课程加入结果当中
            for (int[] p : prerequisites) {
                if (p[1] == curr){
                    inDegrees[p[0]]--;
                    if (inDegrees[p[0]] == 0){
                        queue.offer(p[0]);
                    }
                }
            }
        }
        if (count == numCourses) return res;
        return new int[0];
    }
```





### dfs

#### 面试题13.	机器人的运动范围

```java
class Solution {
    int m,n,k;
    boolean[][] visited;
    public int movingCount(int m, int n, int k) {
        this.m = m;
        this.n = n;
        this.k = k;
        this.visited = new boolean[m][n];
        return dfs(0,0,0,0);
    }
    public int dfs(int i, int j, int si, int sj){
        if (i >= m || j >= n|| si + sj > k ||visited[i][j] == true){
            return 0;
        }
        visited[i][j] = true;
        return 1+dfs(i+1,j,(i+1)%10 != 0? si+1:si-8,sj) + dfs(i,j+1,si,(j+1) % 10!= 0? sj+1:sj-8);
    }
}
```





















# 剑指Offer

## 3.	数组中的重复数

```java
//直接打表,没什么好说的
    public int findRepeatNumber(int[] nums) {
        int[] num = new int[nums.length];
        for(int i = 0; i < nums.length; i++){
            num[nums[i]]++;
            if (num[nums[i]]>1){
                return nums[i];
            }
        }
        return 0;
    }
```





## 4.	二维数组中查找数

```java
//本题和LeetCode240一样
public static boolean findNumberIn2DArray(int[][] matrix, int target) {
        int row = matrix.length;
        if (row == 0) {
            return false;
        }
        int col = matrix[0].length;
        if (col == 0) {
            return false;
        }
        int i = 0;
        int j = col - 1;
        while (i < row && j >= 0) {
            if (matrix[i][j] == target) {
                return true;
            }
            if (matrix[i][j] > target) {
                j--;
            } else {
                i++;
            }
        }
        return false;
    }
```



## 5.	替换空格

```java
public static String replaceSpace(String s) {
        int len = s.length();
        StringBuilder sb  = new StringBuilder();
        for (int i = 0; i < len; i++) {
            char c = s.charAt(i);
            if (c == ' '){
                sb.append("%20");
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }
```





## 6.	反转打印链表

```java
public static int[] reversePrint(ListNode head) {
        return helper(head,0,null);
    }
    public static int[] helper(ListNode head, int num,int[] nums){
        if (head != null && head.next != null){
            num++;
            nums = helper(head.next,num,nums);
        } else if (head == null){
            return new int[0];
        } else {
            num++;
            nums = new int[num];
            nums[num-nums.length] = head.val;
            return nums;
        }
        nums[nums.length-num] = head.val;
        return nums;
    }
```





## 7.※先序中序建立二叉树

```java
// 使用全局变量是为了让递归方法少传一些参数，不一定非要这么做

    private Map<Integer, Integer> reverses;
    private int[] preorder;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int preLen = preorder.length;
        int inLen = inorder.length;

        // 可以不做判断，因为题目中给出的数据都是有效的
        if (preLen != inLen) {
            return null;
        }

        this.preorder = preorder;

        // 以空间换时间，否则，找根结点在中序遍历中的位置需要遍历
        reverses = new HashMap<>(inLen);
        for (int i = 0; i < inLen; i++) {
            reverses.put(inorder[i], i);
        }

        return buildTree(0, preLen - 1, 0, inLen - 1);
    }

    /**
     * 根据前序遍历数组的 [preL, preR] 和 中序遍历数组的 [inL, inR] 重新组建二叉树
     *
     * @param preL 前序遍历数组的区间左端点
     * @param preR 前序遍历数组的区间右端点
     * @param inL  中序遍历数组的区间左端点
     * @param inR  中序遍历数组的区间右端点
     * @return 构建的新二叉树的根结点
     */
    private TreeNode buildTree(int preL, int preR,
                               int inL, int inR) {
        if (preL > preR || inL > inR) {
            return null;
        }
        // 构建的新二叉树的根结点一定是前序遍历数组的第 1 个元素
        int pivot = preorder[preL];
        TreeNode root = new TreeNode(pivot);

        int pivotIndex = reverses.get(pivot);

        // 这一步得画草稿，计算边界的取值，必要时需要解方程，并不难
        root.left = buildTree(preL + 1, preL + (pivotIndex - inL), inL, pivotIndex - 1);
        root.right = buildTree(preL + (pivotIndex - inL) + 1, preR, pivotIndex + 1, inR);
        return root;
    }

```



## 9.	利用两个栈实现队列

```java
static class CQueue {
        Stack<Integer> stack1;
        Stack<Integer> stack2;
        public CQueue() {
            stack1 = new Stack();
            stack2 = new Stack();
        }

        public void appendTail(int value) {
            stack2.add(value);
        }

        public int deleteHead() {
            if (stack1.isEmpty()){
                if (stack2.isEmpty()){
                    return -1;
                } else {
                    while (!stack2.empty()) {
                        stack1.push(stack2.pop());
                    }
                }
            }
            return stack1.pop();
        }
    }
```





## 10-1.	斐波那契数列

```java

    public static int fib(int N) {
        int[] dp = new int[N+1];
        if (N <= 1){
            return N;
        }
        dp[0] = 0;
        dp[1] = 1;

        for (int i = 2; i <= N; i++) {
            dp[i] = dp[i-1]+dp[i-2] % 1000000007;
        }
        return dp[N];
    }
```





## 10-2.	跳楼梯

```java
public static int numWays(int n) {
        int[] dp = new int[n+1];
        if(n <= 1){
            return 1;
        } else if(n == 2){
            return 2;
        }
        dp[0] = 1;
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i <= n; i++){
            dp[i] = (dp[i-1] +dp[i - 2]) % 1000000007;
        }
        return dp[n];
    }
```





## 11.	旋转数组的最小值

```java
public int minArray(int[] numbers) {
        if (numbers.length == 0){
            throw new IllegalArgumentException();
        }
        for(int i = 1; i < numbers.length; i++){
            if (numbers[i] < numbers[i-1]){
                return numbers[i];
            }
        }
        return numbers[0];
    }
```





## 12.	矩阵中的路径

```java
public boolean exist(char[][] board, String word) {
        char[] w = word.toCharArray();
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (bfs(board,w,i,j,0)){
                    return true;
                }
            }
        }
        return false;
    }

    public static boolean bfs(char[][] board, char[] w, int i, int j, int k) {
        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || w[k] != board[i][j]) {
            return false;
        }
        if (k == w.length - 1) {
            return true;
        }
        char tmp = board[i][j];
        board[i][j] = '/';
        boolean res = bfs(board, w, i - 1, j, k + 1) || bfs(board, w, i + 1, j, k + 1) ||
                bfs(board, w, i, j + 1, k + 1) || bfs(board, w, i, j - 1, k + 1);
        board[i][j] = tmp;
        return res;
    }
```





## 13.	机器人的运动范围

```java
class Solution {
    int m,n,k;
    boolean[][] visited;
    public int movingCount(int m, int n, int k) {
        this.m = m;
        this.n = n;
        this.k = k;
        this.visited = new boolean[m][n];
        return dfs(0,0,0,0);
    }
    public int dfs(int i, int j, int si, int sj){
        if (i >= m || j >= n|| si + sj > k ||visited[i][j] == true){
            return 0;
        }
        visited[i][j] = true;
        return 1+dfs(i+1,j,(i+1)%10 != 0? si+1:si-8,sj) + dfs(i,j+1,si,(j+1) % 10!= 0? sj+1:sj-8);
    }
}
```



## 14-1.	剪绳子(dp)

```java
public static int cuttingRope(int n) {
        int[] dp = new int[n+1];
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i / 2; j++) {
                dp[i] = Math.max(Math.max(j*(i-j),dp[i-j]*j),dp[i]);
            }
        }
        return dp[n];
    }
```



## 14-2.	剪绳子2(贪心)

```java
public int cuttingRope(int n) {
        if(n <= 3) return n - 1;
        long res=1L;
        int p=(int)1e9+7;
        //贪心算法，优先切三，其次切二
        while(n>4){
            res=res*3%p;
            n-=3;
        }
        //出来循环只有三种情况，分别是n=2、3、4
        return (int)(res*n%p);
    }
```





## 15.	二进制中1的个数

```java
public static int hammingWeight(int n) {
     int  cnt = 0;
     while(n!=0){
        cnt++;
        n&=(n-1);
     }
	return cnt;
}


```



## 16.	数值的整数次方

```java
public static double myPow(double x, int n) {
        if (n == 0) {
            return 1.0;
        }
        return n > 0 ? helper(x, n) : 1.0 / helper(x, n);
    }

    public static double helper(double x, int M) {
        if (M == 0) {
            return 1.0;
        }
        double y = helper(x, M / 2);
        return M % 2 == 0 ? y * y : y * y * x;
    }
```





## 17.	打印1到最大的n位数

```java
public int[] printNumbers(int n) {
     int num=(int)Math.pow(10,n);
     int[] arr=new int[num-1];
     for(int i=0;i<arr.length;i++){
         arr[i]=i+1;
     }
     return arr;

    }
```







## 18.	删除列表的节点

```java
public ListNode deleteNode(ListNode head, int val) {
        if(head == null){
            return head;
        }
        ListNode p1 = head, p2 = head.next;
        if (p1.val == val){
            head = p2;
            return head;
        }
        while(p2 != null){
            if (p2.val == val && p2.next != null){
                p1.next = p2.next;
                return head;
            } else if(p2.val == val && p2.next == null){
                p1.next = null;
                return head;
            } else{
                p1 = p2;
                p2 = p2.next;
            }
        }
        return head;
    }
```





## 20.	表示数字的字符串

```java
public boolean isNumber(String s) {
        if(s == null || s.length() == 0){
            return false;
        }
        //标记是否遇到相应情况
        boolean numSeen = false;
        boolean dotSeen = false;
        boolean eSeen = false;
        char[] str = s.trim().toCharArray();
        for(int i = 0;i < str.length; i++){
            if(str[i] >= '0' && str[i] <= '9'){
                numSeen = true;
            }else if(str[i] == '.'){
                //.之前不能出现.或者e
                if(dotSeen || eSeen){
                    return false;
                }
                dotSeen = true;
            }else if(str[i] == 'e' || str[i] == 'E'){
                //e之前不能出现e，必须出现数
                if(eSeen || !numSeen){
                    return false;
                }
                eSeen = true;
                numSeen = false;//重置numSeen，排除123e或者123e+的情况,确保e之后也出现数
            }else if(str[i] == '-' || str[i] == '+'){
                //+-出现在0位置或者e/E的后面第一个位置才是合法的
                if(i != 0 && str[i-1] != 'e' && str[i-1] != 'E'){
                    return false;
                }
            }else{//其他不合法字符
                return false;
            }
        }
        return numSeen;
    }
```





## 21.	奇数前,偶数后

```java
public static int[] exchange(int[] nums) {
        int length = nums.length;
        int left = 0;
        int right = length-1;
        while (left < right){
            int temp;
            if (nums[left] % 2 == 0){
                if (nums[right] % 2 != 0){
                    temp = nums[left];
                    nums[left] = nums[right];
                    nums[right] = temp;
                } else {
                    right--;
                }
            } else {
                left++;
            }
        }
        return nums;
    }
```



## 22.	链表中倒数第K个节点

```java
public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode p = head;
        int count = 0;
        while (p != null){
            count++;
            p = p.next;
        }
        p = head;
        while (p != null){
            if (count == k){
                return p;
            }
            count--;
            p = p.next;
        }
        return null;
    }
```





## 24.	反转链表

```java
public ListNode reverseList(ListNode head) {
        if(head == null){
            return null;
        } else if(head.next == null){
            return head;
        }
        return helper(head,head.next,null);
    }
    public static ListNode helper(ListNode p1,ListNode p2,ListNode tail){
        if(p2.next != null){
            tail = helper(p2,p2.next,tail);
        } else {
            tail = p2;
            p2.next = p1;
            p1.next = null;
            return tail;
        }
        p2.next = p1;
        p1.next = null;
        return tail;
    }
```





## 25.	合并两个有序列表

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode p1 = l1, p2 = l2,p3 = null;
        return helper(p1,p2,p3);
    }

    public static ListNode helper(ListNode p1, ListNode p2, ListNode p3){
        if(p1 == null){
            return p2;
        } else if(p2 == null){
            return p1;
        }
        if (p1.val <= p2.val){
            p3 = p1;
            p3.next = helper(p1.next,p2,p3.next);
        } else {
            p3 = p2;
            p3.next = helper(p1,p2.next,p3.next);
        }
        return p3;
    }
```



## 26.	树的子结构

```java
//把原树的每一个子节点都扔进递归中,因为每一个节点都有可能是目标子结构
public boolean isSubStructure(TreeNode A, TreeNode B) {
        return (A!= null && B!= null) && (helpler(A,B) || isSubStructure(A.left,B)||isSubStructure(A.right,B));
    }
    public static boolean helpler(TreeNode A, TreeNode B){
        if (B == null){
            return true;
        } else if (A == null || A.val != B.val) {
            return false;
        }
        return helpler(A.left,B.left) && helpler(A.right,B.right);
    }
```



## 27.	二叉树的镜像

```java
public TreeNode mirrorTree(TreeNode root) {
        TreeNode nroot = null;
        return helper(root,nroot);
    }
    public static TreeNode helper(TreeNode root, TreeNode nroot){
        if (root == null){
            return null;
        }
        nroot = new TreeNode(root.val);
        nroot.right = helper(root.left,nroot.right);
        nroot.left = helper(root.right,nroot.left);
        return nroot;
    }
```





## 28.	对称的树 

```java
public static boolean isSymmetric(TreeNode root) {
        if(root == null){
            return true;
        }
        return helper(root.left,root.right);
    }
    public static boolean helper(TreeNode left, TreeNode right){
        if(left == null && right == null){
            return true;
        }
        if(left == null || right == null || left.val != right.val){
            return false;
        }
        return helper(left.left, right.right) && helper(left.right,right.left);
    }
```



## 29.	螺旋打印数组

```java
public static int[] spiralOrder(int[][] matrix) {
        if(matrix.length == 0) return new int[0];
        int l = 0, r = matrix[0].length - 1, t = 0, b = matrix.length - 1, x = 0;
        int[] res = new int[(r + 1) * (b + 1)];
        while(true) {
            for(int i = l; i <= r; i++) res[x++] = matrix[t][i]; // left to right.
            if(++t > b) break;
            for(int i = t; i <= b; i++) res[x++] = matrix[i][r]; // top to bottom.
            if(l > --r) break;
            for(int i = r; i >= l; i--) res[x++] = matrix[b][i]; // right to left.
            if(t > --b) break;
            for(int i = b; i >= t; i--) res[x++] = matrix[i][l]; // bottom to top.
            if(++l > r) break;
        }
        return res;
    }
```



## 30.	包含min函数的栈

```java
class MinStack {
		Stack<Integer> stack;
        int min;
        /** initialize your data structure here. */
        public MinStack() {
            stack = new Stack();
            min = Integer.MAX_VALUE;
        }

        public void push(int x) {
            if(min >= x){
                stack.push(min);
                min = x;
            }
            stack.push(x);
        }

        public void pop() {
            if(min == stack.pop()){
                min = stack.pop();
            }
        }

        public int top() {
            return stack.peek();
        }

        public int getMin() {
            return min;
        }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```



## 31.	栈的压入弹出序列

```java
public boolean validateStackSequences(int[] pushed, int[] popped) {
        int length = pushed.length;
        Stack<Integer> stack = new Stack();
        int j = 0;
        for(int x : pushed){
            stack.push(x);
            while (!stack.isEmpty() && j < length && stack.peek() == popped[j]){
                stack.pop();
                j++;
            }
        }
        return j == length;
    }
```



## 32-1.	层序遍历二叉树

```java
public int[] levelOrder(TreeNode root) {
        if (root == null){
            return new int[]{};
        }
        Queue<TreeNode> queue = new ArrayDeque<>();
        ArrayList<Integer> arrayList = new ArrayList<>();
        queue.add(root);
        while (!queue.isEmpty()){
            TreeNode treeNode = queue.poll();
            arrayList.add(treeNode.val);
            if (treeNode.left != null){
                queue.add(treeNode.left);
            }
            if (treeNode.right != null){
                queue.add(treeNode.right);
            }
        }
        int[] nums = new int[arrayList.size()];
        for (int i = 0; i < nums.length; i++) {
            nums[i] = arrayList.get(i);
        }
        return nums;
    }
```



## 32-2.	层序遍历二叉树

```java
public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null){
            return new LinkedList<>();
        }
        List<List<Integer>> lists = new LinkedList<>();
        Queue<TreeNode> queue = new ArrayDeque<>();
        queue.add(root);
        while (!queue.isEmpty()){
            LinkedList<Integer> linkedList = new LinkedList<>();
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode treeNode = queue.poll();
                linkedList.add(treeNode.val);
                if (treeNode.left!= null){
                    queue.add(treeNode.left);
                }
                if (treeNode.right!= null){
                    queue.add(treeNode.right);
                }
            }
            lists.add(linkedList);
        }
        return lists;
    }
```



## 32-3.	层序遍历二叉树(奇偶层)

```java
//	bfs做法
public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) {
            return new LinkedList<>();
        }
        List<List<Integer>> lists = new LinkedList<>();
        Queue<TreeNode> queue = new ArrayDeque<>();
        queue.add(root);
        boolean flag = false;
        while (!queue.isEmpty()) {
            LinkedList<Integer> linkedList = new LinkedList<>();
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode treeNode = queue.poll();
                linkedList.add(treeNode.val);
                if (treeNode.left != null) {
                    queue.add(treeNode.left);
                }
                if (treeNode.right != null) {
                    queue.add(treeNode.right);
                }
            }
            if (flag == true){
                Collections.reverse(linkedList);
            }
            flag = !flag;
            lists.add(linkedList);
        }
        return lists;
    }

// 双栈法(stack1存奇数层,stack2存偶数层,利用栈的性质可知,stack1先存左子节点,stack2先存右子节点)
	public static List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) {
            return new LinkedList<>();
        }
        List<List<Integer>> lists = new LinkedList<>();
        Stack<TreeNode> stack1 = new Stack<>();
        Stack<TreeNode> stack2 = new Stack<>();
        boolean flag = true;
        stack1.push(root);
        while (!stack1.isEmpty() || !stack2.isEmpty()){
            List<Integer> list = new LinkedList<>();
            if (flag){
                while (!stack1.isEmpty()){
                    TreeNode treeNode = stack1.pop();
                    list.add(treeNode.val);
                    if (treeNode.left != null){
                        stack2.push(treeNode.left);
                    }
                    if (treeNode.right != null){
                        stack2.push(treeNode.right);
                    }
                }
            } else {
                while (!stack2.isEmpty()){
                    TreeNode treeNode = stack2.pop();
                    list.add(treeNode.val);
                    if (treeNode.right != null){
                        stack1.push(treeNode.right);
                    }
                    if (treeNode.left != null){
                        stack1.push(treeNode.left);
                    }
                }
            }
            lists.add(list);
            flag = !flag;
        }
        return lists;
    }
```





## 33.	二叉搜索树的后序遍历序列

```java
public boolean verifyPostorder(int[] postorder) {
        Stack<Integer> stack = new Stack<>();
        int root = Integer.MAX_VALUE;
        for(int i = postorder.length - 1; i >= 0; i--) {
            if(postorder[i] > root) return false;
            while(!stack.isEmpty() && stack.peek() > postorder[i])
                root = stack.pop();
            stack.add(postorder[i]);
        }
        return true;
    }
```





## 34.	二叉树中到叶子节点的路径之和

```java
public static List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> lists = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        if (root == null) {
            return lists;
        }
        helper(lists, list, root, sum);
        return lists;
    }

    public static List<Integer> helper(List<List<Integer>> lists, List<Integer> list, TreeNode root, int sum) {
        if (root == null) {
            return list;
        }
        list.add(root.val);
        if (sum != root.val || root.left !=null || root.right != null) {
            list = helper(lists, list, root.left, sum-root.val);
            list = helper(lists, list, root.right, sum-root.val);
        }
        if (sum == root.val && root.left == null && root.right == null) {
            List<Integer> list1 = new ArrayList<>();
            for (int i = 0; i < list.size(); i++) {
                list1.add(list.get(i));
            }
            lists.add(list1);
            list.remove(list.size() - 1);
            return list;
        }
        list.remove(list.size()-1);
        return list;
    }
```



## 35.	复杂链表的复制

```java
static Map<Node,Node> map = new HashMap<>();
    public static Node copyRandomList(Node head) {
        if (head == null){
            return null;
        }
        Node root = new Node(head.val);
        map.put(head,root);
        build(head,root);
        createRandom(head,root);
        return root;
    }

    public static void build(Node head, Node root){
        while (head.next!=null){
            Node nextNode = new Node(head.next.val);
            root.next = nextNode;
            map.put(head.next,nextNode);
            head = head.next;
            root = root.next;
        }
    }

    public static void createRandom(Node head, Node root){
        while (head!=null){
            if (head.random!=null){
                root.random = map.get(head.random);
            }
            head = head.next;
            root = root.next;
        }
    }
```





## 36.	二叉搜索树转双向链表

```java
Node pre, head;
    public Node treeToDoublyList(Node root) {
        if(root == null){
            return null;
        }
        dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    }
    void dfs(Node cur) {
        if(cur == null){
            return;
        }
        dfs(cur.left);
        if(pre != null){
            pre.right = cur;
        } else{
            head = cur;
        }
        cur.left = pre;
        pre = cur;
        dfs(cur.right);
    }
```



## 37.	序列化二叉树

```java
public static String serialize(TreeNode root) {
        return helpSerialize(root, "");
    }

    public static String helpSerialize(TreeNode root, String str) {
        if (root == null) {
            str += "null,";
        } else {
            str += root.val + ",";
            str = helpSerialize(root.left, str);
            str = helpSerialize(root.right, str);
        }
        return str;
    }

    // Decodes your encoded data to tree.
    public static TreeNode deserialize(String data) {
        String[] dataArray = data.split(",");
        List<String> list = new LinkedList<>(Arrays.asList(dataArray));
        return buildTree(list);
    }

    public static TreeNode buildTree(List<String> list){
        if (list.get(0).equals("null")){
            list.remove(0);
            return null;
        }
        TreeNode root = new TreeNode(Integer.valueOf(list.get(0)));
        list.remove(0);
        root.left = buildTree(list);
        root.right = buildTree(list);
        return root;
    }
```



## 38.	字符串的排列

```java
List<String> res = new LinkedList<>();
    char[] c;

    public String[] permutation(String s) {
        c = s.toCharArray();
        dfs(0);
        return res.toArray(new String[res.size()]);
    }

    void dfs(int x) {
        if (x == c.length - 1) {
            res.add(String.valueOf(c)); // 添加排列方案
            return;
        }
        HashSet<Character> set = new HashSet<>();
        for (int i = x; i < c.length; i++) {
            if (set.contains(c[i])) {
                continue; // 重复，因此剪枝
            }
            set.add(c[i]);
            swap(i, x); // 交换，将 c[i] 固定在第 x 位
            dfs(x + 1); // 开启固定第 x + 1 位字符
            swap(i, x); // 恢复交换
        }
    }

    void swap(int a, int b) {
        char tmp = c[a];
        c[a] = c[b];
        c[b] = tmp;
    }
```





## 39.	寻找数组中出现次数大于一半的数

```java
//解法1:候选人算法,如果当前候选人并非上次记录的候选人,则上次记录的候选人票数减一
public static int majorityElement(int[] nums) {
        int count = 0;
        int candidate = nums[0];
        for (int num : nums) {
            if (count == 0){
                candidate = num;
            }
            count += (candidate == num)? 1:-1;
        }
        return candidate;
}
//解法2:先进行排序,出现次数大于一半的数的位置一定会出现在nums.lenth/2
public static int majorityElement(int[] nums) {
	Arrays.sort(nums);
	return nums[nums.length/2];
}
```





## 40.	最小的k个数

```java
public int[] getLeastNumbers(int[] arr, int k) {
        if (k == 0) {
            return new int[0];
        }
        // 使用一个最大堆（大顶堆）
        // Java 的 PriorityQueue 默认是小顶堆，添加 comparator 参数使其变成最大堆
        Queue<Integer> heap = new PriorityQueue<>(k, (i1, i2) -> Integer.compare(i2, i1));

        for (int e : arr) {
            // 当前数字小于堆顶元素才会入堆
            if (heap.isEmpty() || heap.size() < k || e < heap.peek()) {
                heap.offer(e);
            }
            if (heap.size() > k) {
                heap.poll(); // 删除堆顶最大元素
            }
        }

        // 将堆中的元素存入数组
        int[] res = new int[heap.size()];
        int j = 0;
        for (int e : heap) {
            res[j++] = e;
        }
        return res;
    }
```





## 41.	数据流中的中位数

```java
class MedianFinder {
        Queue<Integer> A, B;
        public MedianFinder() {
            A = new PriorityQueue<>(); // 小顶堆，保存较大的一半
            B = new PriorityQueue<>((x, y) -> (y - x)); // 大顶堆，保存较小的一半
        }
        public void addNum(int num) {
            if(A.size() != B.size()) {
                A.add(num);
                B.add(A.poll());
            } else {
                B.add(num);
                A.add(B.poll());
            }
        }
        public double findMedian() {
            return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;
        }
    }
```





## 42.	最大子序和

```java
public int maxSubArray(int[] nums) {
        int max = nums[0];
        for(int i = 1; i < nums.length; i++){
            if(nums[i-1] > 0){
                nums[i]+=nums[i-1];
            }
            max = Math.max(nums[i],max);
        }
        return max;
    }
```





## 43.	1~n中1出现的次数

```java
public int countDigitOne(int n) {
        int digit = 1, res = 0;
        int high = n / 10, cur = n % 10, low = 0;
        while(high != 0 || cur != 0) {
            if(cur == 0) res += high * digit;
            else if(cur == 1) res += high * digit + low + 1;
            else res += (high + 1) * digit;
            low += cur * digit;
            cur = high % 10;
            high /= 10;
            digit *= 10;
        }
        return res;
    }
```

